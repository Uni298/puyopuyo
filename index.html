<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <title>ã·ã‚ˆã·ã‚ˆ ãƒãƒˆãƒ«ãƒ­ãƒ¯ã‚¤ã‚¢ãƒ«</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        background: #f8f9fa;
        font-family: 'JetBrains Mono', monospace;
        touch-action: none;
        color: #333;
      }
      #game-container {
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
        border-radius: 20px;
        overflow: hidden;
        max-width: 100%;
        max-height: 100%;
        background: #ffffff;
      }
      canvas {
        display: block;
        margin: 0 auto;
      }

      /* ãƒ­ãƒ“ãƒ¼ç”»é¢ */
      #lobby {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 50px;
        border-radius: 24px;
        text-align: center;
        color: #333;
        z-index: 1000;
        min-width: 480px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
        border: 1px solid rgba(0, 0, 0, 0.05);
      }

      #lobby h1 {
        margin-bottom: 40px;
        color: #2c3e50;
        font-weight: 800;
        font-size: 28px;
      }

      .btn {
        background: #4a90e2;
        border: none;
        padding: 16px 32px;
        margin: 12px;
        border-radius: 12px;
        color: white;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 4px 6px rgba(74, 144, 226, 0.3);
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(74, 144, 226, 0.4);
        background: #357abd;
      }

      .btn:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(74, 144, 226, 0.3);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .btn.ready {
        background: #2ecc71;
        box-shadow: 0 4px 6px rgba(46, 204, 113, 0.3);
      }

      .btn.ready:hover {
        background: #27ae60;
        box-shadow: 0 6px 12px rgba(46, 204, 113, 0.4);
      }

      #roomCodeInput {
        padding: 16px;
        font-size: 18px;
        border-radius: 12px;
        border: 2px solid #e1e4e8;
        text-align: center;
        margin: 15px;
        width: 220px;
        text-transform: uppercase;
        transition: border-color 0.2s;
        background: #f8f9fa;
        color: #333;
      }

      #roomCodeInput:focus {
        outline: none;
        border-color: #4a90e2;
        background: #fff;
      }

      #roomCode {
        font-size: 42px;
        font-weight: 800;
        color: #2c3e50;
        margin: 25px 0;
        letter-spacing: 8px;
        font-family: monospace;
      }

      #status {
        margin-top: 25px;
        font-size: 15px;
        color: #666;
        font-weight: 500;
      }

      #playerList {
        margin: 25px 0;
        text-align: left;
        background: #f8f9fa;
        padding: 20px;
        border-radius: 16px;
        border: 1px solid #e1e4e8;
      }

      .player-item {
        padding: 12px 16px;
        margin: 8px 0;
        background: #ffffff;
        border-radius: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.03);
        border: 1px solid #eee;
      }

      .player-item.ready {
        background: #f0fff4;
        border-left: 4px solid #2ecc71;
        border-color: #c6f6d5;
      }

      .player-item.host {
        border-left: 4px solid #f1c40f;
      }

      h3 {
        color: #2c3e50;
        font-size: 16px;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid #e1e4e8;
      }

      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <!-- ãƒ­ãƒ“ãƒ¼ç”»é¢ -->
    <div id="lobby">
      <h1>ğŸ® ã·ã‚ˆã·ã‚ˆ ãƒãƒˆãƒ«ãƒ­ãƒ¯ã‚¤ã‚¢ãƒ«</h1>

      <div id="mainMenu">
        <input
          type="text"
          id="playerNameInput"
          placeholder="åå‰ (ä»»æ„)"
          maxlength="20"
          style="padding: 16px; font-size: 16px; border-radius: 12px; border: 2px solid #e1e4e8; text-align: center; margin: 15px; width: 220px; background: #f8f9fa; color: #333;"
        />
        <br />
        <button class="btn" onclick="createRoom()">ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆ</button>
        <br />
        <input
          type="text"
          id="roomCodeInput"
          placeholder="ãƒ«ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰"
          maxlength="6"
        />
        <br />
        <button class="btn" onclick="joinRoom()">ãƒ«ãƒ¼ãƒ ã«å‚åŠ </button>
      </div>

      <div id="waitingRoom" class="hidden">
        <h2>ãƒ«ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰</h2>
        <div id="roomCode"></div>

        <div id="playerList"></div>

        <div id="status">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å¾…ã£ã¦ã„ã¾ã™...</div>
        <div id="hostSettings" style="margin: 20px 0; padding: 10px; background: #fff; border-radius: 8px;">
            <div style="margin-bottom: 8px;">
                <label for="garbageRate">ãŠã˜ã‚ƒã¾ãƒ¬ãƒ¼ãƒˆ: </label>
                <input type="number" id="garbageRate" min="0.1" max="5.0" step="0.1" value="1.0" style="width: 60px;"> å€
            </div>
            <div style="margin-bottom: 8px;">
                <label for="dropSpeed">è½ä¸‹é€Ÿåº¦: </label>
                <input type="number" id="dropSpeed" min="50" max="2000" step="50" value="500" style="width: 60px;"> ms
            </div>
            <div>
                <label for="defeatTime">æ•—åŒ—çŒ¶äºˆ: </label>
                <input type="number" id="defeatTime" min="3" max="60" step="1" value="10" style="width: 60px;"> ç§’
            </div>
        </div>

        <button id="readyBtn" class="btn" onclick="toggleReady()">
          æº–å‚™å®Œäº†
        </button>
        <br />
        <button class="btn" onclick="leaveRoom()">é€€å‡º</button>
        
        <!-- ãƒãƒ£ãƒƒãƒˆ -->
        <div style="margin-top: 20px; background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
          <h3 style="margin: 0 0 10px 0; font-size: 16px;">Chat</h3>
          <div id="chatMessages" style="height: 150px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 5px; padding: 10px; margin-bottom: 10px; font-size: 13px;"></div>
          <div style="display: flex; gap: 5px;">
            <input type="text" id="chatInput" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›..." style="flex: 1; padding: 8px; border: 1px solid #555; border-radius: 5px; font-size: 13px; background: rgba(255,255,255,0.9);" maxlength="100">
            <button onclick="sendChat()" style="padding: 8px 15px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 13px;">é€ä¿¡</button>
          </div>
        </div>
      </div>
    </div>

    <div id="game-container"></div>

    <script>
      const COLS = 6;
      const ROWS = 14;
      const CELL_SIZE = 40;
      const BORDER_LINE = 4;
      const COLORS = ['red', 'blue', 'green', 'yellow', 'purple'];
      const COLOR_VALUES = {
          'red': 0xff3333,
          'blue': 0x3366ff,
          'green': 0x33cc33,
          'yellow': 0xffcc00,
          'purple': 0xcc33ff,
          'gray': 0x888888
      };

      // WebSocketæ¥ç¶š
      let ws = null;
      let currentRoom = null;
      let isHost = false;
      let myPlayerId = null;
      let myReady = false;
      let allPlayers = [];

      function connectWebSocket() {
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          ws = new WebSocket(`${protocol}//${window.location.host}`);

          ws.onopen = () => {
              console.log('Connected to server');
          };

          ws.onmessage = (event) => {
              const data = JSON.parse(event.data);
              handleServerMessage(data);
          };

          ws.onclose = () => {
              console.log('Disconnected from server');
              setTimeout(connectWebSocket, 3000);
          };

          ws.onerror = (error) => {
              console.error('WebSocket error:', error);
          };
      }

      function handleServerMessage(data) {
          switch (data.type) {
              case 'room_created':
                  currentRoom = data.roomCode;
                  myPlayerId = data.playerId;
                  isHost = true;
                  showWaitingRoom(data.roomCode);
                  
                  // ãƒ›ã‚¹ãƒˆæ¨©é™UIæ›´æ–°
                  // ãƒ›ã‚¹ãƒˆæ¨©é™UIæ›´æ–°
                  const updateSettings = () => {
                      if (ws && ws.readyState === WebSocket.OPEN) {
                          ws.send(JSON.stringify({
                              type: 'update_settings',
                              settings: { 
                                  garbageRate: parseFloat(document.getElementById('garbageRate').value),
                                  dropSpeed: parseInt(document.getElementById('dropSpeed').value),
                                  defeatTime: parseInt(document.getElementById('defeatTime').value)
                              }
                          }));
                      }
                  };

                  document.getElementById('garbageRate').disabled = false;
                  document.getElementById('dropSpeed').disabled = false;
                  document.getElementById('defeatTime').disabled = false;
                  
                  document.getElementById('garbageRate').onchange = updateSettings;
                  document.getElementById('dropSpeed').onchange = updateSettings;
                  document.getElementById('defeatTime').onchange = updateSettings;
                  break;

              case 'room_joined':
                  currentRoom = data.roomCode;
                  myPlayerId = data.playerId;
                  isHost = false;
                  showWaitingRoom(data.roomCode);
                  break;

              case 'you_are_host':
                  isHost = true;
                  break;

              case 'room_state':
                  allPlayers = data.players;
                  updatePlayerList(data.players, data.hostId);

                  // å…¨å“¡æº–å‚™å®Œäº†ãƒã‚§ãƒƒã‚¯
                  const allReady = data.players.every(p => p.ready);
                  if (allReady && data.players.length >= 2) {
                      document.getElementById('status').textContent = 'ã¾ã‚‚ãªãé–‹å§‹...';
                  } else if (data.players.length < 2) {
                      document.getElementById('status').textContent = 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å¾…ã£ã¦ã„ã¾ã™... (æœ€ä½2äººå¿…è¦)';
                  } else {
                      document.getElementById('status').textContent = `${data.players.filter(p => p.ready).length}/${data.players.length} äººæº–å‚™å®Œäº†`;
                  }
                  
                  // è¨­å®šåæ˜ 
                  if (data.settings) {
                      const garbageInput = document.getElementById('garbageRate');
                      const dropInput = document.getElementById('dropSpeed');
                      const defeatInput = document.getElementById('defeatTime');
                      
                      if (document.activeElement !== garbageInput) garbageInput.value = data.settings.garbageRate;
                      if (document.activeElement !== dropInput) dropInput.value = data.settings.dropSpeed || 500;
                      if (document.activeElement !== defeatInput) defeatInput.value = data.settings.defeatTime || 10;
                      
                      // ãƒ›ã‚¹ãƒˆä»¥å¤–ã¯ç„¡åŠ¹åŒ–
                      const isMyHost = (data.hostId === myPlayerId);
                      garbageInput.disabled = !isMyHost;
                      dropInput.disabled = !isMyHost;
                      defeatInput.disabled = !isMyHost;
                      
                      // ãƒ›ã‚¹ãƒˆæ¨©é™æ›´æ–°
                      if (isMyHost) {
                          const updateSettings = () => {
                              if (ws && ws.readyState === WebSocket.OPEN) {
                                  ws.send(JSON.stringify({
                                      type: 'update_settings',
                                      settings: { 
                                          garbageRate: parseFloat(garbageInput.value),
                                          dropSpeed: parseInt(dropInput.value),
                                          defeatTime: parseInt(defeatInput.value)
                                      }
                                  }));
                              }
                          };
                          garbageInput.onchange = updateSettings;
                          dropInput.onchange = updateSettings;
                          defeatInput.onchange = updateSettings;
                      } else {
                          garbageInput.onchange = null;
                          dropInput.onchange = null;
                          defeatInput.onchange = null;
                      }
                  }
                  break;

              case 'game_start':
                  allPlayers = data.players;
                  hideWaitingRoom();
                  if (game && game.scene.scenes[0]) {
                      game.scene.scenes[0].startNewGame(data.players, data.settings);
                  }
                  break;

              case 'error':
                  alert(data.message);
                  break;

              case 'opponent_update':
                  if (game && game.scene.isActive('MultiplayerPuyoPuyo')) {
                      game.scene.scenes[0].updateOpponentField(data.playerId, data.data);
                  }
                  break;

              case 'receive_garbage':
                  if (game && game.scene.isActive('MultiplayerPuyoPuyo')) {
                      game.scene.scenes[0].receiveGarbage(data.fromPlayerId, data.amount, data.colors, data.sourcePositions);
                  }
                  break;

              case 'player_defeated':
                  if (game && game.scene.isActive('MultiplayerPuyoPuyo')) {
                      game.scene.scenes[0].handlePlayerDefeated(data.playerId);
                  }
                  break;

              case 'game_end':
                  if (game && game.scene.isActive('MultiplayerPuyoPuyo')) {
                      game.scene.scenes[0].handleGameEnd(data.winnerId, data.isWinner);
                  }
                  break;

              case 'piece_update':
                  if (game && game.scene.isActive('MultiplayerPuyoPuyo')) {
                      game.scene.scenes[0].updateOpponentPiece(data.playerId, data.data);
                  }
                  break;

              case 'third_party_attack':
                  if (game && game.scene.isActive('MultiplayerPuyoPuyo')) {
                      game.scene.scenes[0].showThirdPartyAttack(data.fromPlayerId, data.toPlayerId, data.amount, data.sourcePositions);
                  }
                  break;

              case 'hard_drop_animation':
                  if (game && game.scene.isActive('MultiplayerPuyoPuyo')) {
                      game.scene.scenes[0].showOpponentHardDrop(data.playerId, data.data);
                  }
                  break;

              case 'clear_animation':
                  if (game && game.scene.isActive('MultiplayerPuyoPuyo')) {
                      game.scene.scenes[0].showOpponentClear(data.playerId, data.data);
                  }
                  break;

              case 'chat_message':
                  const chatMessages = document.getElementById('chatMessages');
                  if (chatMessages) {
                      const msgDiv = document.createElement('div');
                      msgDiv.style.marginBottom = '5px';
                      msgDiv.style.wordWrap = 'break-word';
                      msgDiv.innerHTML = `<strong>${data.playerName}:</strong> ${escapeHtml(data.message)}`;
                      chatMessages.appendChild(msgDiv);
                      chatMessages.scrollTop = chatMessages.scrollHeight;
                  }
                  break;
          }
      }
      
      function escapeHtml(text) {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
      }
      
      function sendChat() {
          const input = document.getElementById('chatInput');
          const message = input.value.trim();
          if (message && ws && ws.readyState === WebSocket.OPEN && currentRoom) {
              ws.send(JSON.stringify({
                  type: 'chat_message',
                  message: message
              }));
              input.value = '';
          }
      }
      
      // Enterã‚­ãƒ¼ã§ãƒãƒ£ãƒƒãƒˆé€ä¿¡
      document.addEventListener('DOMContentLoaded', () => {
          const chatInput = document.getElementById('chatInput');
          if (chatInput) {
              chatInput.addEventListener('keypress', (e) => {
                  if (e.key === 'Enter') {
                      sendChat();
                  }
              });
          }
      });

      function createRoom() {
          if (ws && ws.readyState === WebSocket.OPEN) {
              const playerName = document.getElementById('playerNameInput').value.trim();
              ws.send(JSON.stringify({ 
                  type: 'create_room',
                  playerName: playerName || undefined
              }));
          }
      }

      function joinRoom() {
          const roomCode = document.getElementById('roomCodeInput').value.toUpperCase();
          if (roomCode.length === 6 && ws && ws.readyState === WebSocket.OPEN) {
              const playerName = document.getElementById('playerNameInput').value.trim();
              ws.send(JSON.stringify({
                  type: 'join_room',
                  roomCode: roomCode,
                  playerName: playerName || undefined
              }));
          } else {
              alert('6æ¡ã®ãƒ«ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
          }
      }

      function toggleReady() {
          if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'toggle_ready' }));
              myReady = !myReady;

              const btn = document.getElementById('readyBtn');
              if (myReady) {
                  btn.textContent = 'æº–å‚™è§£é™¤';
                  btn.classList.add('ready');
              } else {
                  btn.textContent = 'æº–å‚™å®Œäº†';
                  btn.classList.remove('ready');
              }
          }
      }

      function leaveRoom() {
          if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'leave_room' }));
          }
          location.reload();
      }

      function showWaitingRoom(roomCode) {
          document.getElementById('mainMenu').classList.add('hidden');
          document.getElementById('waitingRoom').classList.remove('hidden');
          document.getElementById('roomCode').textContent = roomCode;
      }

      function hideWaitingRoom() {
          document.getElementById('lobby').classList.add('hidden');
      }

      function returnToLobby() {
          document.getElementById('lobby').classList.remove('hidden');
          myReady = false;
          const btn = document.getElementById('readyBtn');
          btn.textContent = 'æº–å‚™å®Œäº†';
          btn.classList.remove('ready');
      }

      function updatePlayerList(players, hostId) {
          const list = document.getElementById('playerList');
          list.innerHTML = '<h3>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸€è¦§</h3>';

          players.forEach(player => {
              const item = document.createElement('div');
              item.className = 'player-item';
              if (player.ready) item.classList.add('ready');
              if (player.id === hostId) item.classList.add('host');

              const name = document.createElement('span');
              name.textContent = player.name;
              if (player.id === hostId) name.textContent += ' ğŸ‘‘';
              if (player.id === myPlayerId) name.textContent += ' (ã‚ãªãŸ)';

              const status = document.createElement('span');
              status.textContent = player.ready ? 'âœ… æº–å‚™å®Œäº†' : 'â³ å¾…æ©Ÿä¸­';
              status.style.color = player.ready ? '#33cc33' : '#888';

              item.appendChild(name);
              item.appendChild(status);
              list.appendChild(item);
          });
      }

      class MultiplayerPuyoPuyo extends Phaser.Scene {
          constructor() {
              super({ key: 'MultiplayerPuyoPuyo' });
              this.grid = [];
              this.opponentFields = new Map();
              this.currentPair = null;
              this.nextPair = null;
              this.score = 0;
              this.gameOver = false;
              this.isMoving = false;
              this.chainCount = 0;
              this.comboCount = 0;  // ã‚³ãƒ³ãƒœã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
              this.lastPlacementCleared = false;  // å‰å›ã®è¨­ç½®ã§æ¶ˆãˆãŸã‹ã©ã†ã‹
              this.pendingGarbageCount = 0;  // å¤‰æ›´: é…åˆ—ã‹ã‚‰æ•°å€¤ã¸
              this.garbageQueue = []; // { amount: number, time: number }
              this.gameStarted = false;
              this.players = [];
              this.alivePlayers = [];
              this.defeatTimer = null;
              this.defeatTimer = null;
              this.defeatCountdownText = null;
              this.is1v1Mode = false;
              this.garbageRate = 1.0;
              this.isBoardAnimating = false; // ç›¤é¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ãƒ•ãƒ©ã‚°
          }

          preload() {
              this.createGradientTexture();
          }

          createGradientTexture() {
              const graphics = this.add.graphics();
              // ãƒ¢ãƒ€ãƒ³ãªç™½ãƒ™ãƒ¼ã‚¹ã®ãŸã‚ã€èƒŒæ™¯ã¯è–„ã„ã‚°ãƒ¬ãƒ¼ã®ã‚¹ãƒˆãƒ©ã‚¤ãƒ—ãªã©ã«å¤‰æ›´ã€ã¾ãŸã¯å˜è‰²
              graphics.fillStyle(0xf0f2f5, 1);
              graphics.fillRect(0, 0, COLS * CELL_SIZE, ROWS * CELL_SIZE);

              // ã‚°ãƒªãƒƒãƒ‰ç·š
              graphics.lineStyle(1, 0xe1e4e8, 1);
              for (let i = 0; i <= ROWS; i++) {
                  graphics.moveTo(0, i * CELL_SIZE);
                  graphics.lineTo(COLS * CELL_SIZE, i * CELL_SIZE);
              }
              for (let i = 0; i <= COLS; i++) {
                  graphics.moveTo(i * CELL_SIZE, 0);
                  graphics.lineTo(i * CELL_SIZE, ROWS * CELL_SIZE);
              }
              graphics.strokePath();

              graphics.generateTexture('gradient', COLS * CELL_SIZE, ROWS * CELL_SIZE);
              graphics.destroy();
          }

          create() {
              // å¾…æ©Ÿãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
              this.waitingText = this.add.text(
                  this.cameras.main.centerX,
                  this.cameras.main.centerY,
                  'ã‚²ãƒ¼ãƒ é–‹å§‹ã‚’å¾…ã£ã¦ã„ã¾ã™...',
                  {
                      fontSize: '32px',
                      fontFamily: '"JetBrains Mono"',
                      fill: '#fff',
                      fontStyle: 'bold'
                  }
              ).setOrigin(0.5);

              // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰è¨­å®š
              this.cursors = this.input.keyboard.createCursorKeys();
              this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

              // ã‚¿ãƒƒãƒãƒ»ã‚¹ãƒ¯ã‚¤ãƒ—è¨­å®š
              this.setupTouchControls();

              this.lastMoveTime = 0;
              this.lastRotateTime = 0;
              this.lockDelayTimer = null;
              this.isOnGround = false;

              // æ•—åŒ—ã‚¿ã‚¤ãƒãƒ¼ç”¨ãƒ†ã‚­ã‚¹ãƒˆ
              this.defeatCountdownText = this.add.text(0, 0, '', {
                  fontSize: '64px',
                  fontFamily: '"JetBrains Mono"',
                  fill: '#ff0000',
                  fontStyle: 'bold',
                  stroke: '#ffffff',
                  strokeThickness: 6
              }).setOrigin(0.5).setDepth(1000).setVisible(false);
          }

          startNewGame(players, settings) {
              if (this.gameStarted) return;
              this.gameStarted = true;
              this.players = players;
              this.alivePlayers = players.map(p => p.id);
              this.gameSettings = settings || {};
              this.garbageRate = (this.gameSettings.garbageRate) ? this.gameSettings.garbageRate : 1.0;
              this.zoomedPlayerId = null;

              // å¾…æ©Ÿãƒ†ã‚­ã‚¹ãƒˆã‚’å‰Šé™¤
              if (this.waitingText) {
                  this.waitingText.destroy();
                  this.waitingText = null;
              }

              // æ—¢å­˜ã®è¦ç´ ã‚’ã‚¯ãƒªã‚¢
              this.children.removeAll(true);

              // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
              this.score = 0;
              this.gameOver = false;
              this.isMoving = false;
              this.isBoardAnimating = false;
              this.chainCount = 0;
              this.pendingGarbageCount = 0;
              this.garbageQueue = [];
              if (this.defeatTimer) {
                  this.defeatTimer.remove();
                  this.defeatTimer = null;
              }
              if (this.defeatCountdownText) {
                  this.defeatCountdownText.setVisible(false);
                  this.defeatCountdownText = null; 
              }

              // æ•—åŒ—ã‚¿ã‚¤ãƒãƒ¼ç”¨ãƒ†ã‚­ã‚¹ãƒˆå†ç”Ÿæˆ
              this.defeatCountdownText = this.add.text(0, 0, '', {
                  fontSize: '64px',
                  fontFamily: '"JetBrains Mono"',
                  fill: '#ff0000',
                  fontStyle: 'bold',
                  stroke: '#ffffff',
                  strokeThickness: 6
              }).setOrigin(0.5).setDepth(1000).setVisible(false);

              // ã‚°ãƒªãƒƒãƒ‰ã‚’ã‚¯ãƒªã‚¢
              for (let row = 0; row < ROWS; row++) {
                  this.grid[row] = [];
                  for (let col = 0; col < COLS; col++) {
                      this.grid[row][col] = null;
                  }
              }

              this.opponentFields.clear();

              this.opponentFields.clear();
              
              // 1v1ãƒ¢ãƒ¼ãƒ‰åˆ¤å®š
              this.is1v1Mode = (players.length === 2);
              
              let offsetX = 50;
              
              if (this.is1v1Mode) {
                  // 1v1ã®å ´åˆã¯ç”»é¢ä¸­å¤®ã«å¯„ã›ã‚‹
                  // ã‚²ãƒ¼ãƒ å¹…1000px, ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¹… COLS*CELL_SIZE + ä½™ç™½
                  // å·¦ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰: 250pxä»˜è¿‘, å³ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰: 550pxä»˜è¿‘
                  const fieldWidth = COLS * CELL_SIZE;
                  const totalWidth = fieldWidth * 2 + 100; // é–“ã®ã‚¹ãƒšãƒ¼ã‚¹100px
                  offsetX = (1000 - totalWidth) / 2;
              }

              // è‡ªåˆ†ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆå·¦å´ï¼‰
              this.createField(offsetX, 'YOU');
              this.fieldOffsetX = offsetX;

              // ç›¸æ‰‹ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’é…ç½®
              this.createOpponentFields(players);

              // ã‚¹ã‚³ã‚¢è¡¨ç¤º
              this.scoreText = this.add.text(offsetX, ROWS * CELL_SIZE + 20, 'SCORE: 0', {
                  fontSize: '18px',
                  fontFamily: '"JetBrains Mono"',
                  fill: '#333',
                  fontStyle: 'bold'
              });

              // ãƒã‚§ã‚¤ãƒ³è¡¨ç¤º
              this.chainText = this.add.text(offsetX + COLS * CELL_SIZE / 2, ROWS * CELL_SIZE / 2, '', {
                  fontSize: '28px',
                  fontFamily: '"JetBrains Mono"',
                  fill: '#ffcc00',
                  fontStyle: 'bold'
              }).setOrigin(0.5).setDepth(100);

              // ã‚³ãƒ³ãƒœè¡¨ç¤º
              this.comboText = this.add.text(offsetX + COLS * CELL_SIZE / 2, ROWS * CELL_SIZE / 2 + 40, '', {
                  fontSize: '20px',
                  fontFamily: '"JetBrains Mono"',
                  fill: '#ff6b6b',
                  fontStyle: 'bold'
              }).setOrigin(0.5).setDepth(100);

              // äºˆå‘Šã‚²ãƒ¼ã‚¸èƒŒæ™¯ (ä¸‹å¯„ã›)
              this.garbageGaugeBg = this.add.rectangle(
                  offsetX + COLS * CELL_SIZE + 15,
                  ROWS * CELL_SIZE,
                  20,
                  ROWS * CELL_SIZE,
                  0x333333,
                  0.3
              ).setOrigin(0, 1).setDepth(50);

              // äºˆå‘Šã‚²ãƒ¼ã‚¸ (ä¸‹å¯„ã›)
              this.garbageGauge = this.add.rectangle(
                  offsetX + COLS * CELL_SIZE + 15,
                  ROWS * CELL_SIZE,
                  20,
                  0,
                  0xff6b6b,
                  0.8
              ).setOrigin(0, 1).setDepth(51);

              // äºˆå‘Šæ•°å€¤
              this.garbageCountText = this.add.text(
                  offsetX + COLS * CELL_SIZE + 25,
                  ROWS * CELL_SIZE / 2 - ROWS * CELL_SIZE / 2 - 20,
                  '',
                  {
                      fontSize: '16px',
                      fontFamily: '"JetBrains Mono"',
                      fill: '#ff6b6b',
                      fontStyle: 'bold'
                  }
              ).setOrigin(0.5).setDepth(52);

              // Nextè¡¨ç¤º (å·¦æ¨ªã€æ ã®ä¸‹ã®æ–¹)
              const nextX = offsetX - 70;
              const nextY = ROWS * CELL_SIZE - 50;
              this.add.text(nextX, nextY - 40, 'NEXT:', {
                  fontSize: '16px',
                  fontFamily: '"JetBrains Mono"',
                  fill: '#333'
              }).setOrigin(0.5);
              this.nextContainer = this.add.container(nextX, nextY);

              // ã‚²ãƒ¼ãƒ é–‹å§‹
              this.nextPair = this.createPuyoPair();
              this.spawnNewPair();

              if (this.dropTimer) {
                  this.dropTimer.remove();
              }

              const dropDelay = (this.gameSettings && this.gameSettings.dropSpeed) ? this.gameSettings.dropSpeed : 300;
              this.dropTimer = this.time.addEvent({
                  delay: dropDelay,
                  callback: this.autoDrop,
                  callbackScope: this,
                  loop: true
              });
          }

          createField(x, label) {
              // èƒŒæ™¯
              const bg = this.add.rectangle(
                  x + COLS * CELL_SIZE / 2,
                  ROWS * CELL_SIZE / 2,
                  COLS * CELL_SIZE,
                  ROWS * CELL_SIZE,
                  0xffffff
              ).setOrigin(0.5).setDepth(-10);
              bg.setData('myField', true);

              const gradient = this.add.image(x, 0, 'gradient').setOrigin(0).setDepth(-10);
              gradient.setData('myField', true);

              // æ 
              const border = this.add.rectangle(
                  x + COLS * CELL_SIZE / 2,
                  ROWS * CELL_SIZE / 2,
                  COLS * CELL_SIZE + 4,
                  ROWS * CELL_SIZE + 4,
                  0x000000,
                  0
              ).setOrigin(0.5).setDepth(-5);
              border.setStrokeStyle(4, 0x2c3e50);
              border.setData('myFieldBorder', true);
              this.myFieldBorder = border;

              // ãƒœãƒ¼ãƒ€ãƒ¼ãƒ©ã‚¤ãƒ³
              const borderY = BORDER_LINE * CELL_SIZE;
              const graphics = this.add.graphics();
              graphics.lineStyle(3, 0xff0000, 0.8);
              graphics.setDepth(100);

              for (let i = 0; i < COLS * CELL_SIZE; i += 10) {
                  if (Math.floor(i / 10) % 2 === 0) {
                      graphics.lineBetween(x + i, borderY, x + Math.min(i + 5, COLS * CELL_SIZE), borderY);
                  }
              }
              graphics.setData('myField', true);

              // ãƒ©ãƒ™ãƒ«
              this.add.text(x + COLS * CELL_SIZE / 2, -25, label, {
                  fontSize: '20px',
                  fontFamily: '"JetBrains Mono"',
                  fill: '#333',
                  fontStyle: 'bold'
              }).setOrigin(0.5);
          }

          createOpponentFields(players) {
              const opponents = players.filter(p => p.id !== myPlayerId);
              
              if (this.is1v1Mode && opponents.length === 1) {
                   // 1v1ãƒ¢ãƒ¼ãƒ‰: ç›¸æ‰‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚‚è‡ªåˆ†ã¨åŒã˜ã‚µã‚¤ã‚ºãƒ»è¦‹ãŸç›®ã§å³å´ã«é…ç½®
                   const playerX = this.fieldOffsetX;
                   const opponentX = playerX + COLS * CELL_SIZE + 100; // 100pxã®é–“éš”
                   const opponentY = 0; // Yåº§æ¨™ã¯åŒã˜
                   
                   const field = {
                       x: opponentX,
                       y: opponentY, // createFieldæº–æ‹ ã®Yåº§æ¨™ (0åŸºæº–)
                       width: COLS * CELL_SIZE,
                       height: ROWS * CELL_SIZE,
                       scale: 1.0, 
                       grid: [],
                       border: null,
                       bg: null,
                       name: null,
                       playerId: opponents[0].id,
                       originalProps: null
                   };
                   
                   // ã‚°ãƒªãƒƒãƒ‰åˆæœŸåŒ–
                   for (let row = 0; row < ROWS; row++) {
                       field.grid[row] = [];
                       for (let col = 0; col < COLS; col++) {
                           field.grid[row][col] = null;
                       }
                   }

                   // èƒŒæ™¯ (createFieldã¨åŒã˜ã‚¹ã‚¿ã‚¤ãƒ«)
                   // field.x, field.yã¯å·¦ä¸ŠåŸºæº–ã¨ã—ã¦æ‰±ã†ãŒã€add.rectangleã¯ä¸­å¿ƒåŸºæº–ãªã®ã§èª¿æ•´ãŒå¿…è¦
                   // createFieldã®å®Ÿè£…ã‚’è¦‹ã‚‹é™ã‚Šã€(x, 0)èµ·ç‚¹ã§æç”»ã—ã¦ã„ã‚‹
                   
                   const centerX = opponentX + COLS * CELL_SIZE / 2;
                   const centerY = ROWS * CELL_SIZE / 2;
                   
                   field.bg = this.add.rectangle(
                       centerX,
                       centerY,
                       COLS * CELL_SIZE,
                       ROWS * CELL_SIZE,
                       0xffffff
                   ).setOrigin(0.5).setDepth(-10);
                   field.bg.setData('myField', false); 
                   
                   // ã‚ºãƒ¼ãƒ æ©Ÿèƒ½ã®ãŸã‚ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³
                   field.bg.setInteractive();
                   field.bg.on('pointerdown', () => this.toggleZoom(field.playerId));

                   const gradient = this.add.image(opponentX, 0, 'gradient').setOrigin(0).setDepth(-10);
                   
                   // æ 
                   field.border = this.add.rectangle(
                       centerX,
                       centerY,
                       COLS * CELL_SIZE + 4,
                       ROWS * CELL_SIZE + 4,
                       0x000000,
                       0
                   ).setOrigin(0.5).setDepth(-5);
                   field.border.setStrokeStyle(4, 0x2c3e50);
                   
                   // ãƒœãƒ¼ãƒ€ãƒ¼ãƒ©ã‚¤ãƒ³ (èµ¤ç·š)
                   const borderY = BORDER_LINE * CELL_SIZE;
                   const graphics = this.add.graphics();
                   graphics.lineStyle(3, 0xff0000, 0.8);
                   graphics.setDepth(100);
                   for (let i = 0; i < COLS * CELL_SIZE; i += 10) {
                       if (Math.floor(i / 10) % 2 === 0) {
                           graphics.lineBetween(opponentX + i, borderY, opponentX + Math.min(i + 5, COLS * CELL_SIZE), borderY);
                       }
                   }
                   
                   // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å
                   field.name = this.add.text(centerX, -25, opponents[0].name, {
                       fontSize: '20px',
                       fontFamily: '"JetBrains Mono"',
                       fill: '#333',
                       fontStyle: 'bold'
                   }).setOrigin(0.5);
                   
                   this.opponentFields.set(opponents[0].id, field);
                   
              } else {
                  // é€šå¸¸ã®Battle Royaleãƒ¢ãƒ¼ãƒ‰ï¼ˆã‚°ãƒªãƒƒãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼‰
                  const startX = 50 + COLS * CELL_SIZE + 80;
                  const fieldWidth = COLS * CELL_SIZE * 0.4;  // ã•ã‚‰ã«å°ã•ã
                  const fieldHeight = ROWS * CELL_SIZE * 0.4;
                  const spacing = 15;
                  
                  // ã‚°ãƒªãƒƒãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆ2åˆ—ï¼‰
                  const cols = 2;
                  const maxVisibleRows = Math.floor((this.cameras.main.height - 100) / (fieldHeight + spacing + 30));
    
                  opponents.forEach((player, index) => {
                      const col = index % cols;
                      const row = Math.floor(index / cols);
                      
                      const x = startX + col * (fieldWidth + spacing + 20);
                      const y = 50 + row * (fieldHeight + spacing + 30);
    
                      const field = {
                          x: x,
                          y: y,
                          width: fieldWidth,
                          height: fieldHeight,
                          scale: 0.4,
                          grid: [],
                          border: null,
                          bg: null,
                          name: null,
                          playerId: player.id,
                          originalProps: null,
                          puyoSprites: []  // ãƒ•ãƒ«ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨
                      };
    
                      // ã‚°ãƒªãƒƒãƒ‰åˆæœŸåŒ–
                      for (let row = 0; row < ROWS; row++) {
                          field.grid[row] = [];
                          for (let col = 0; col < COLS; col++) {
                              field.grid[row][col] = null;
                          }
                      }
    
                      // èƒŒæ™¯
                      field.bg = this.add.rectangle(
                          x + fieldWidth / 2,
                          y + fieldHeight / 2,
                          fieldWidth,
                          fieldHeight,
                          0xffffff
                      ).setOrigin(0.5);
    
                      // ã‚ºãƒ¼ãƒ æ©Ÿèƒ½ã®ãŸã‚ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³
                      field.bg.setInteractive();
                      field.bg.on('pointerdown', () => this.toggleZoom(field.playerId));
    
                      // æ 
                      field.border = this.add.rectangle(
                          x + fieldWidth / 2,
                          y + fieldHeight / 2,
                          fieldWidth + 2,
                          fieldHeight + 2,
                          0x000000,
                          0
                      ).setOrigin(0.5);
                      field.border.setStrokeStyle(2, 0x95a5a6);
    
                      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å
                      field.name = this.add.text(x + fieldWidth / 2, y - 15, player.name, {
                          fontSize: '12px',
                          fontFamily: '"JetBrains Mono"',
                          fill: '#333',
                          fontStyle: 'bold'
                      }).setOrigin(0.5);
    
                      this.opponentFields.set(player.id, field);
                  });
              }
          }

          updateOpponentField(playerId, gridData) {
              const field = this.opponentFields.get(playerId);
              if (!field) return;

              // æ—¢å­˜ã®ã·ã‚ˆã‚’ã‚¯ãƒªã‚¢
              for (let row = 0; row < ROWS; row++) {
                  for (let col = 0; col < COLS; col++) {
                      if (field.grid[row][col]) {
                          field.grid[row][col].destroy();
                          field.grid[row][col] = null;
                      }
                  }
              }

              // 1v1ãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯ã‚ºãƒ¼ãƒ ä¸­ã¯ãƒ•ãƒ«ãƒ†ã‚¯ã‚¹ãƒãƒ£ã€ãã‚Œä»¥å¤–ã¯å††å½¢
              const useFullTexture = this.is1v1Mode || (this.zoomedPlayerId === playerId);

              // æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã§æç”»
              for (let row = 0; row < ROWS; row++) {
                  for (let col = 0; col < COLS; col++) {
                      if (gridData[row][col]) {
                          const x = field.x + col * CELL_SIZE * field.scale + (CELL_SIZE * field.scale) / 2;
                          const y = field.y + row * CELL_SIZE * field.scale + (CELL_SIZE * field.scale) / 2;
                          
                          let puyo;
                          if (useFullTexture) {
                              // è‡ªåˆ†ã¨åŒã˜ãƒ•ãƒ«ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½¿ç”¨
                              const radius = CELL_SIZE * 0.38 * field.scale;
                              const baseColor = COLOR_VALUES[gridData[row][col]];
                              
                              puyo = this.add.container(x, y);
                              
                              // å½±
                              const shadow = this.add.circle(2 * field.scale, 2 * field.scale, radius, 0x000000, 0.3);
                              puyo.add(shadow);
                              
                              // æœ¬ä½“
                              const body = this.add.circle(0, 0, radius, baseColor);
                              puyo.add(body);
                              
                              // æš—ã„éƒ¨åˆ†
                              const darkPart = this.add.circle(0, radius * 0.2, radius * 0.9,
                                  Phaser.Display.Color.IntegerToColor(baseColor).darken(15).color);
                              puyo.add(darkPart);
                              
                              // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                              const highlight1 = this.add.circle(-radius * 0.3, -radius * 0.3, radius * 0.4, 0xffffff, 0.5);
                              puyo.add(highlight1);
                              
                              const highlight2 = this.add.circle(radius * 0.2, -radius * 0.35, radius * 0.2, 0xffffff, 0.3);
                              puyo.add(highlight2);
                              
                              // æ ç·š
                              const outline = this.add.circle(0, 0, radius);
                              outline.setStrokeStyle(2 * field.scale, 0xffffff, 0.8);
                              outline.setFillStyle(0, 0);
                              puyo.add(outline);
                              
                              puyo.setSize(CELL_SIZE * field.scale, CELL_SIZE * field.scale);
                          } else {
                              // ç°¡æ˜“ç‰ˆï¼ˆå††ã®ã¿ï¼‰
                              puyo = this.add.circle(x, y, CELL_SIZE * 0.38 * field.scale, COLOR_VALUES[gridData[row][col]]);
                              puyo.setStrokeStyle(2 * field.scale, 0xffffff, 0.8);
                          }
                          
                          puyo.setData('color', gridData[row][col]);
                          if (field.bg) {
                              puyo.setDepth(field.bg.depth + 1);
                          }
                          
                          field.grid[row][col] = puyo;
                      }
                  }
              }
          }

          toggleZoom(playerId) {
              // è¦³æˆ¦è€…ï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼çŠ¶æ…‹ï¼‰ã®ã¿ã‚ºãƒ¼ãƒ å¯èƒ½
              if (!this.gameOver) return;

              const field = this.opponentFields.get(playerId);
              if (!field) return;

              if (this.zoomedPlayerId === playerId) {
                  // ã‚ºãƒ¼ãƒ è§£é™¤
                  if (field.originalProps) {
                     this.tweens.add({
                         targets: field,
                         x: field.originalProps.x,
                         y: field.originalProps.y,
                         scale: field.originalProps.scale,
                         duration: 300,
                         ease: 'Power2',
                         onUpdate: () => {
                             this.updateFieldVisuals(field);
                         },
                         onComplete: () => {
                             field.bg.setDepth(field.originalProps.depth);
                             this.updateFieldVisuals(field); // å¿µã®ãŸã‚
                         }
                     });
                     
                     // ä»–ã®è¦ç´ ã®Depthã‚‚æˆ»ã™å¿…è¦ãŒã‚ã‚‹ãŒã€updateFieldVisualsã§ãƒ™ãƒ¼ã‚¹Depthã‹ã‚‰ã®ç›¸å¯¾å€¤ã§è¨­å®šã™ã‚‹
                  }
                  this.zoomedPlayerId = null;
              } else {
                  // ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚ºãƒ¼ãƒ ä¸­ãªã‚‰è§£é™¤
                  if (this.zoomedPlayerId) {
                      this.toggleZoom(this.zoomedPlayerId);
                  }

                  // ã‚ºãƒ¼ãƒ é–‹å§‹
                  field.originalProps = {
                      x: field.x,
                      y: field.y,
                      scale: field.scale,
                      depth: field.bg.depth
                  };

                  const targetScale = 1.0; // å¸¸ã«1.0å€ï¼ˆã¾ãŸã¯ç”»é¢ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦èª¿æ•´å¯ï¼‰
                  const targetX = (this.cameras.main.width - (COLS * CELL_SIZE * targetScale)) / 2;
                  const targetY = (this.cameras.main.height - (ROWS * CELL_SIZE * targetScale)) / 2;
                  const targetDepth = 5000; // æœ€å‰é¢

                  field.bg.setDepth(targetDepth);
                  
                  this.tweens.add({
                      targets: field,
                      x: targetX,
                      y: targetY,
                      scale: targetScale,
                      duration: 300,
                      ease: 'Power2',
                      onUpdate: () => {
                          this.updateFieldVisuals(field);
                      }
                  });

                  this.zoomedPlayerId = playerId;
              }
          }

          updateFieldVisuals(field) {
              // èƒŒæ™¯
              const width = COLS * CELL_SIZE * field.scale;
              const height = ROWS * CELL_SIZE * field.scale;
              
              field.bg.setPosition(field.x + width / 2, field.y + height / 2);
              field.bg.setDisplaySize(width, height);
              
              // æ 
              if (field.border) {
                  field.border.setPosition(field.x + width / 2, field.y + height / 2);
                  field.border.setDisplaySize(width + 4, height + 4);
                  field.border.setDepth(field.bg.depth + 10);
              }

              // åå‰
              if (field.name) {
                  field.name.setPosition(field.x + width / 2, field.y - 15 * (field.scale / 0.5)); // ã‚¹ã‚±ãƒ¼ãƒ«ã«å¿œã˜ã¦èª¿æ•´
                  field.name.setScale(field.scale / 0.5); // å…ƒãŒ0.5ãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºãªã‚‰èª¿æ•´
                  field.name.setDepth(field.bg.depth + 10);
              }

              // ã·ã‚ˆ (gridå†é…ç½®)
              for (let row = 0; row < ROWS; row++) {
                  for (let col = 0; col < COLS; col++) {
                      const puyo = field.grid[row][col];
                      if (puyo) {
                          const px = field.x + col * CELL_SIZE * field.scale + (CELL_SIZE * field.scale) / 2;
                          const py = field.y + row * CELL_SIZE * field.scale + (CELL_SIZE * field.scale) / 2;
                          puyo.setPosition(px, py);
                          // Only set radius if it's a circle (not a container)
                          if (puyo.type === 'Arc') {
                              puyo.setRadius(CELL_SIZE * 0.38 * field.scale);
                          }
                          if (field.bg) {
                              puyo.setDepth(field.bg.depth + 1);
                          }
                      }
                  }
              }
              
              // æ“ä½œä¸­ãƒ”ãƒ¼ã‚¹ã®ä½ç½®ã‚‚æ›´æ–°
              if (field.pieceContainer) {
                  field.pieceContainer.list.forEach(piece => {
                      // ãƒ”ãƒ¼ã‚¹ã¯æ—¢ã«updateOpponentPieceã§æ­£ã—ã„åº§æ¨™ã«é…ç½®ã•ã‚Œã¦ã„ã‚‹ãŒã€
                      // ã‚¹ã‚±ãƒ¼ãƒ«ã‚„Depthã‚’æ›´æ–°ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                      piece.setDepth(field.bg.depth + 10);
                  });
              }
          }

          createSmallPuyo(x, y, color, scale) {
              const radius = CELL_SIZE * 0.38 * scale;
              const puyo = this.add.circle(x, y, radius, COLOR_VALUES[color], 0.8);
              return puyo;
          }

          setupTouchControls() {
              this.touchStartX = 0;
              this.touchStartY = 0;
              this.touchStartTime = 0;
              this.swipeThreshold = 30;

              this.input.on('pointerdown', (pointer) => {
                  if (this.gameOver) return;
                  this.touchStartX = pointer.x;
                  this.touchStartY = pointer.y;
                  this.touchStartTime = this.time.now;
              });

              this.input.on('pointerup', (pointer) => {
                  if (this.gameOver || !this.currentPair || this.isMoving) return;

                  const deltaX = pointer.x - this.touchStartX;
                  const deltaY = pointer.y - this.touchStartY;
                  const deltaTime = this.time.now - this.touchStartTime;
                  const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                  if (distance < this.swipeThreshold && deltaTime < 300) {
                      this.rotatePair();
                  } else if (distance > this.swipeThreshold) {
                      const angle = Math.atan2(deltaY, deltaX);
                      const absAngle = Math.abs(angle);

                      if (angle > Math.PI / 4 && angle < 3 * Math.PI / 4) {
                          this.hardDrop();
                      } else if (angle < -Math.PI / 4 && angle > -3 * Math.PI / 4) {
                          this.rotatePair();
                      } else if (absAngle < Math.PI / 4) {
                          this.movePair(1);
                      } else if (absAngle > 3 * Math.PI / 4) {
                          this.movePair(-1);
                      }
                  }
              });
          }

          createPuyo(x, y, color, isGhost = false, customAlpha = 1) {
              const puyo = this.add.container(x, y);
              const radius = CELL_SIZE * 0.38;

              const shadow = this.add.circle(2, 2, radius, 0x000000, 0.3);
              puyo.add(shadow);

              const baseColor = COLOR_VALUES[color];
              const body = this.add.circle(0, 0, radius, baseColor);
              puyo.add(body);

              const darkPart = this.add.circle(0, radius * 0.2, radius * 0.9,
                  Phaser.Display.Color.IntegerToColor(baseColor).darken(15).color);
              puyo.add(darkPart);

              const highlight1 = this.add.circle(-radius * 0.3, -radius * 0.3, radius * 0.4, 0xffffff, 0.5);
              puyo.add(highlight1);

              const highlight2 = this.add.circle(radius * 0.2, -radius * 0.35, radius * 0.2, 0xffffff, 0.3);
              puyo.add(highlight2);

              const outline = this.add.circle(0, 0, radius);
              outline.setStrokeStyle(2, 0xffffff, 0.8);
              outline.setFillStyle(0, 0);
              puyo.add(outline);

              puyo.setData('color', color);
              puyo.setAlpha(isGhost ? 0.3 : customAlpha);
              puyo.setSize(CELL_SIZE, CELL_SIZE);

              if (!isGhost && customAlpha === 1) {
                  puyo.setScale(0);
                  puyo.setAngle(-180);
                  this.tweens.add({
                      targets: puyo,
                      scale: 1,
                      angle: 0,
                      duration: 300,
                      ease: 'Elastic.easeOut'
                  });

                  this.tweens.add({
                      targets: puyo,
                      scaleX: { from: 1, to: 1.08 },
                      scaleY: { from: 1, to: 0.92 },
                      duration: 800,
                      yoyo: true,
                      repeat: -1,
                      ease: 'Sine.easeInOut'
                  });
              }

              return puyo;
          }

          createPuyoPair() {
              const color1 = Phaser.Utils.Array.GetRandom(COLORS);
              const color2 = Phaser.Utils.Array.GetRandom(COLORS);
              return {
                  main: { color: color1, sprite: null },
                  sub: { color: color2, sprite: null },
                  col: Math.floor(COLS / 2),
                  row: 0,
                  rotation: 0
              };
          }

          spawnNewPair() {
              if (this.gameOver) return;

              this.currentPair = this.nextPair;
              this.nextPair = this.createPuyoPair();

              const startX = this.fieldOffsetX + this.currentPair.col * CELL_SIZE + CELL_SIZE / 2;
              const startY = this.currentPair.row * CELL_SIZE + CELL_SIZE / 2;

              this.currentPair.main.sprite = this.createPuyo(startX, startY, this.currentPair.main.color);
              this.currentPair.sub.sprite = this.createPuyo(startX, startY - CELL_SIZE, this.currentPair.sub.color);

              this.currentPair.ghostMain = null;
              this.currentPair.ghostSub = null;

              this.time.delayedCall(100, () => {
                  if (this.currentPair) {
                      this.updateGhostPieces();
                  }
              });

              this.updateNextDisplay();

              // ãƒœãƒ¼ãƒ€ãƒ¼ãƒ©ã‚¤ãƒ³ãƒã‚§ãƒƒã‚¯ï¼ˆdefeatTimerã¯checkBorderLineã§ç®¡ç†ï¼‰
              this.checkBorderLine();
          }

          updateGhostPieces() {
              if (this.currentPair && this.currentPair.ghostMain) {
                  this.currentPair.ghostMain.destroy();
                  this.currentPair.ghostMain = null;
              }
              if (this.currentPair && this.currentPair.ghostSub) {
                  this.currentPair.ghostSub.destroy();
                  this.currentPair.ghostSub = null;
              }

              if (!this.currentPair || this.isMoving) return;

              let dropRow = this.currentPair.row;
              while (true) {
                  const testRow = dropRow + 1;
                  const positions = this.getPairPositions(this.currentPair.col, testRow, this.currentPair.rotation);
                  if (!this.isValidPosition(positions)) break;
                  dropRow = testRow;
              }

              if (dropRow === this.currentPair.row) return;

              const ghostPositions = this.getPairPositions(this.currentPair.col, dropRow, this.currentPair.rotation);

              const ghostMainX = this.fieldOffsetX + ghostPositions.main.col * CELL_SIZE + CELL_SIZE / 2;
              const ghostMainY = ghostPositions.main.row * CELL_SIZE + CELL_SIZE / 2;
              const ghostSubX = this.fieldOffsetX + ghostPositions.sub.col * CELL_SIZE + CELL_SIZE / 2;
              const ghostSubY = ghostPositions.sub.row * CELL_SIZE + CELL_SIZE / 2;

              this.currentPair.ghostMain = this.add.circle(
                  ghostMainX, ghostMainY, CELL_SIZE * 0.25,
                  COLOR_VALUES[this.currentPair.main.color], 0.4
              );
              this.currentPair.ghostMain.setDepth(50);
              this.currentPair.ghostMain.setStrokeStyle(1.5, 0x666666, 0.4);

              this.currentPair.ghostSub = this.add.circle(
                  ghostSubX, ghostSubY, CELL_SIZE * 0.25,
                  COLOR_VALUES[this.currentPair.sub.color], 0.4
              );
              this.currentPair.ghostSub.setDepth(50);
              this.currentPair.ghostSub.setStrokeStyle(1.5, 0x666666, 0.4);
          }

          updateNextDisplay() {
              this.nextContainer.removeAll(true);
              const next1 = this.createPuyo(0, 0, this.nextPair.main.color);
              const next2 = this.createPuyo(0, -CELL_SIZE, this.nextPair.sub.color);
              next1.setScale(0.6);
              next2.setScale(0.6);
              this.nextContainer.add([next1, next2]);
          }

          update(time) {
              if (this.gameOver || !this.currentPair || this.isMoving || !this.gameStarted) return;

              if (this.cursors.left.isDown && time > this.lastMoveTime + 150) {
                  this.movePair(-1);
                  this.lastMoveTime = time;
              } else if (this.cursors.right.isDown && time > this.lastMoveTime + 150) {
                  this.movePair(1);
                  this.lastMoveTime = time;
              }

              if (Phaser.Input.Keyboard.JustDown(this.cursors.up) && time > this.lastRotateTime + 50) {
                  this.rotatePair();
                  this.lastRotateTime = time;
              }

              if (Phaser.Input.Keyboard.JustDown(this.spaceKey) || Phaser.Input.Keyboard.JustDown(this.cursors.down)) {
                  this.hardDrop();
              }

              // æ•—åŒ—ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
              if (this.defeatTimer) {
                  const remaining = Math.ceil(this.defeatTimer.getRemaining() / 1000);
                  this.defeatCountdownText.setText(remaining.toString());
                  this.defeatCountdownText.setPosition(
                      this.fieldOffsetX + COLS * CELL_SIZE / 2,
                      ROWS * CELL_SIZE / 2
                  );
                  this.defeatCountdownText.setVisible(true);
              } else {
                  this.defeatCountdownText.setVisible(false);
              }
          }

          movePair(dir) {
              const newCol = this.currentPair.col + dir;
              const positions = this.getPairPositions(newCol, this.currentPair.row, this.currentPair.rotation);

              if (this.isValidPosition(positions)) {
                  this.currentPair.col = newCol;
                  this.updatePairPosition();
                  this.updateGhostPieces();
                  this.resetLockDelay();
                  this.sendPieceUpdate();
              }
          }

          rotatePair() {
              const newRotation = (this.currentPair.rotation + 1) % 4;
              const positions = this.getPairPositions(this.currentPair.col, this.currentPair.row, newRotation);

              if (this.isValidPosition(positions)) {
                  this.currentPair.rotation = newRotation;
                  this.updatePairPosition();
                  this.updateGhostPieces();
                  this.resetLockDelay();
                  this.sendPieceUpdate();
              
                  this.tweens.add({
                      targets: this.currentPair.main.sprite,
                      angle: '+=360',
                      duration: 200,
                      ease: 'Back.easeOut'
                  });

                  this.tweens.add({
                      targets: this.currentPair.sub.sprite,
                      angle: '+=360',
                      duration: 200,
                      ease: 'Back.easeOut'
                  });
              }
          }

          resetLockDelay() {
              if (this.lockDelayTimer) {
                  this.lockDelayTimer.remove();
                  this.lockDelayTimer = null;
              }
              this.isOnGround = false;
          }

          hardDrop() {
              if (!this.currentPair || this.isMoving) return;

              let dropRow = this.currentPair.row;
              while (true) {
                  const testRow = dropRow + 1;
                  const positions = this.getPairPositions(this.currentPair.col, testRow, this.currentPair.rotation);
                  if (!this.isValidPosition(positions)) break;
                  dropRow = testRow;
              }

              const distance = dropRow - this.currentPair.row;
              if (distance > 0) {
                  // ãƒˆãƒ¬ã‚¤ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¿½åŠ 
                  const startY = this.currentPair.row * CELL_SIZE + CELL_SIZE / 2;
                  const endY = dropRow * CELL_SIZE + CELL_SIZE / 2;
                  
                  // ãƒ¡ã‚¤ãƒ³ã·ã‚ˆã®ãƒˆãƒ¬ã‚¤ãƒ«
                  const mainX = this.fieldOffsetX + this.currentPair.col * CELL_SIZE + CELL_SIZE / 2;
                  for (let i = 0; i < 5; i++) {
                      const trail = this.add.circle(
                          mainX,
                          startY + (endY - startY) * (i / 5),
                          CELL_SIZE * 0.3,
                          COLOR_VALUES[this.currentPair.main.color],
                          0.3 - i * 0.05
                      );
                      trail.setDepth(50);
                      this.tweens.add({
                          targets: trail,
                          alpha: 0,
                          duration: 200,
                          delay: i * 20,
                          onComplete: () => trail.destroy()
                      });
                  }
                  
                  this.currentPair.row = dropRow;

                  const positions = this.getPairPositions(
                      this.currentPair.col,
                      dropRow,
                      this.currentPair.rotation
                  );

                  this.tweens.add({
                      targets: this.currentPair.main.sprite,
                      x: this.fieldOffsetX + positions.main.col * CELL_SIZE + CELL_SIZE / 2,
                      y: positions.main.row * CELL_SIZE + CELL_SIZE / 2,
                      duration: 100,
                      ease: 'Power2'
                  });

                  this.tweens.add({
                      targets: this.currentPair.sub.sprite,
                      x: this.fieldOffsetX + positions.sub.col * CELL_SIZE + CELL_SIZE / 2,
                      y: positions.sub.row * CELL_SIZE + CELL_SIZE / 2,
                      duration: 100,
                      ease: 'Power2',
                      onComplete: () => {
                          this.lockPair();
                      }
                  });
                  
                  // ãƒãƒ¼ãƒ‰ãƒ‰ãƒ­ãƒƒãƒ—ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é€ä¿¡
                  if (ws && ws.readyState === WebSocket.OPEN) {
                      ws.send(JSON.stringify({
                          type: 'hard_drop_animation',
                          data: {
                              col: this.currentPair.col,
                              startRow: this.currentPair.row - distance,
                              endRow: dropRow,
                              color: this.currentPair.main.color
                          }
                      }));
                  }
              }

              // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å…¨ä½“ã‚’ãƒã‚¦ãƒ³ãƒ‰ã•ã›ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
              const fieldElements = this.children.list.filter(child => 
                  child.getData('myField') || child.getData('myFieldBorder')
              );
              
               // è‡ªåˆ†ã®ã·ã‚ˆã‚‚å«ã‚ã‚‹
               const myPuyos = [];
               for(let r=0; r<ROWS; r++){
                   for(let c=0; c<COLS; c++){
                       if(this.grid[r][c]) myPuyos.push(this.grid[r][c]);
                   }
               }
               
               this.tweens.add({
                   targets: [...fieldElements, ...myPuyos],
                   y: '+=10',
                   duration: 50,
                   yoyo: true,
                   ease: 'Sine.easeInOut'
               });
          }

          getPairPositions(col, row, rotation) {
              const main = { col: col, row: row };
              let sub;

              switch(rotation) {
                  case 0: sub = { col: col, row: row - 1 }; break;
                  case 1: sub = { col: col + 1, row: row }; break;
                  case 2: sub = { col: col, row: row + 1 }; break;
                  case 3: sub = { col: col - 1, row: row }; break;
              }

              return { main, sub };
          }

          isValidPosition(positions) {
              for (let pos of [positions.main, positions.sub]) {
                  if (pos.col < 0 || pos.col >= COLS || pos.row >= ROWS) return false;
                  if (pos.row >= 0 && this.grid[pos.row][pos.col] !== null) return false;
              }
              return true;
          }

          updatePairPosition() {
              const positions = this.getPairPositions(
                  this.currentPair.col,
                  this.currentPair.row,
                  this.currentPair.rotation
              );

              this.tweens.add({
                  targets: this.currentPair.main.sprite,
                  x: this.fieldOffsetX + positions.main.col * CELL_SIZE + CELL_SIZE / 2,
                  y: positions.main.row * CELL_SIZE + CELL_SIZE / 2,
                  duration: 100
              });

              this.tweens.add({
                  targets: this.currentPair.sub.sprite,
                  x: this.fieldOffsetX + positions.sub.col * CELL_SIZE + CELL_SIZE / 2,
                  y: positions.sub.row * CELL_SIZE + CELL_SIZE / 2,
                  duration: 100
              });
          }

          autoDrop() {
              if (!this.gameOver && this.currentPair && !this.isMoving && this.gameStarted) {
                  this.dropPair();
              }
          }

          dropPair() {
              const newRow = this.currentPair.row + 1;
              const positions = this.getPairPositions(this.currentPair.col, newRow, this.currentPair.rotation);

              if (this.isValidPosition(positions)) {
                  this.currentPair.row = newRow;
                  this.updatePairPosition();
                  this.updateGhostPieces();
                  this.resetLockDelay();
                  this.sendPieceUpdate();
              } else {
                  if (!this.isOnGround) {
                      this.isOnGround = true;
                      this.lockDelayTimer = this.time.delayedCall(500, () => {
                          this.lockPair();
                      });
                  }
              }
          }

          async lockPair() {
              this.isMoving = true;

              if (this.lockDelayTimer) {
                  this.lockDelayTimer.remove();
                  this.lockDelayTimer = null;
              }
              this.isOnGround = false;

              // é€£é–ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ãªã©ã¯å¾…æ©Ÿ
              if (this.isBoardAnimating) {
                  await this.waitForBoardStability();
              }

              if (this.currentPair.ghostMain) {
                  this.currentPair.ghostMain.destroy();
                  this.currentPair.ghostMain = null;
              }
              if (this.currentPair.ghostSub) {
                  this.currentPair.ghostSub.destroy();
                  this.currentPair.ghostSub = null;
              }

              const positions = this.getPairPositions(
                  this.currentPair.col,
                  this.currentPair.row,
                  this.currentPair.rotation
              );

              if (positions.main.row >= 0) {
                  this.grid[positions.main.row][positions.main.col] = this.currentPair.main.sprite;
              } else {
                  this.currentPair.main.sprite.destroy();
              }

              if (positions.sub.row >= 0) {
                  this.grid[positions.sub.row][positions.sub.col] = this.currentPair.sub.sprite;
              } else {
                  this.currentPair.sub.sprite.destroy();
              }

              this.currentPair = null;

              // æ¬¡ã®æ“ä½œã‚’è¨±å¯ï¼ˆéåŒæœŸå‡¦ç†é–‹å§‹ï¼‰
              this.processBoardMatches(); // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§é€£é–å‡¦ç†
              
              this.isMoving = false;
              this.spawnNewPair();
          }

          async waitForBoardStability() {
              while (this.isBoardAnimating) {
                  await this.delay(50);
              }
          }

          async processBoardMatches() {
              this.isBoardAnimating = true;

              this.chainCount = 0;  // ãƒã‚§ã‚¤ãƒ³ã¯ãƒªã‚»ãƒƒãƒˆ
              // ã‚³ãƒ³ãƒœã¯ãƒªã‚»ãƒƒãƒˆã—ãªã„ï¼ˆæ¶ˆãˆãªã‹ã£ãŸã‚‰ãƒªã‚»ãƒƒãƒˆï¼‰
              
              await this.checkAndClearMatches();
              await this.applyGravity();

              // å¾…æ©Ÿã‚­ãƒ¥ãƒ¼ã‹ã‚‰ç¢ºå®šã¸ç§»å‹• (æ™‚é–“ãŒçµŒéã—ãŸã‚‚ã®)
              if (this.garbageQueue) {
                  const now = this.time.now;
                  // é€†é †ã§ãƒ«ãƒ¼ãƒ—ã—ã¦å®‰å…¨ã«å‰Šé™¤
                  for (let i = this.garbageQueue.length - 1; i >= 0; i--) {
                      if (now >= this.garbageQueue[i].time) {
                          this.pendingGarbageCount += this.garbageQueue[i].amount;
                          this.garbageQueue.splice(i, 1);
                      }
                  }
              }

              // ãŠã˜ã‚ƒã¾ã·ã‚ˆã®å‡¦ç†
              if (this.pendingGarbageCount > 0) {
                  // å°‘ã—é…ã‚‰ã›ã¦ãŠã˜ã‚ƒã¾ã·ã‚ˆã®è½ä¸‹æ¼”å‡º
                  this.time.delayedCall(200, () => {
                      this.dropGarbagePuyos(); // ã“ã‚Œã‚‚éåŒæœŸã‹ã‚‚ï¼Ÿä¸€æ—¦ã“ã“ã§å‘¼ã³å‡ºã—
                  });
              }

              this.sendFieldUpdate();
              
              this.isBoardAnimating = false;
          }

          async checkAndClearMatches() {
              const MAX_LOOPS = 20;
              let loopCount = 0;
              let hasMatches = true;
              
              // æœ€åˆã®ãƒãƒƒãƒãƒã‚§ãƒƒã‚¯
              const initialMatched = this.findMatches();
              const clearedThisPlacement = initialMatched.length > 0;
              
              // ã‚³ãƒ³ãƒœåˆ¤å®š: å‰å›ã‚‚ä»Šå›ã‚‚æ¶ˆãˆãŸå ´åˆã®ã¿ã‚³ãƒ³ãƒœ
              if (clearedThisPlacement && this.lastPlacementCleared) {
                  this.comboCount++;
              } else if (clearedThisPlacement && !this.lastPlacementCleared) {
                  // ä»Šå›åˆã‚ã¦æ¶ˆãˆãŸå ´åˆã¯ã‚³ãƒ³ãƒœ1
                  this.comboCount = 1;
              } else {
                  // æ¶ˆãˆãªã‹ã£ãŸå ´åˆã¯ãƒªã‚»ãƒƒãƒˆ
                  this.comboCount = 0;
              }
              
              // ä»Šå›ã®çµæœã‚’ä¿å­˜
              this.lastPlacementCleared = clearedThisPlacement;
              
              // ã‚³ãƒ³ãƒœè¡¨ç¤ºï¼ˆ2ã‚³ãƒ³ãƒœä»¥ä¸Šã§è¡¨ç¤ºï¼‰
              if (this.comboCount >= 2) {
                  this.comboText.setText(`${this.comboCount} COMBO!`);
                  this.tweens.add({
                      targets: this.comboText,
                      scale: 1.3,
                      yoyo: true,
                      duration: 200
                  });
              } else {
                  this.comboText.setText('');
              }

              while (hasMatches && loopCount < MAX_LOOPS) {
                  loopCount++;
                  const matched = loopCount === 1 ? initialMatched : this.findMatches(); // Use initialMatched for the first loop

                  if (matched.length === 0) {
                      hasMatches = false;
                      this.chainText.setText('');
                  } else {
                      this.chainCount++;
                      if (this.chainCount > 1) {
                          this.chainText.setText(`${this.chainCount} é€£é–ï¼`);
                          this.tweens.add({
                              targets: this.chainText,
                              scale: 1.5,
                              yoyo: true,
                              duration: 200
                          });
                      }

                      const positions = matched.map(m => ({
                          x: this.fieldOffsetX + m.col * CELL_SIZE + CELL_SIZE / 2,
                          y: m.row * CELL_SIZE + CELL_SIZE / 2
                      }));

                      await this.clearPuyos(matched);

                      this.score += matched.length * 10 * this.chainCount;
                      this.scoreText.setText(`SCORE: ${this.score}`);

                      // ãŠã˜ã‚ƒã¾ã·ã‚ˆè¨ˆç®—ï¼ˆãƒã‚§ã‚¤ãƒ³ + ã‚³ãƒ³ãƒœï¼‰
                      const baseGarbage = Math.floor((matched.length / 2) * this.garbageRate);
                      const comboBonus = Math.max(0, this.comboCount - 1);  // 2ã‚³ãƒ³ãƒœä»¥ä¸Šã§ãƒœãƒ¼ãƒŠã‚¹
                      const totalGarbage = baseGarbage + comboBonus;
                      
                      if (totalGarbage > 0) {
                          // ç›¸æ®ºå‡¦ç†
                          let remainingOffset = totalGarbage;
                          
                          // 1. ç¢ºå®šæ¸ˆã¿ã®ãŠã˜ã‚ƒã¾ã·ã‚ˆã‹ã‚‰ç›¸æ®º
                          if (this.pendingGarbageCount > 0) {
                              const offset = Math.min(remainingOffset, this.pendingGarbageCount);
                              this.pendingGarbageCount -= offset;
                              remainingOffset -= offset;
                          }
                          
                          // 2. å¾…æ©Ÿã‚­ãƒ¥ãƒ¼ã®ãŠã˜ã‚ƒã¾ã·ã‚ˆã‹ã‚‰ç›¸æ®º (å¤ã„é †)
                          if (remainingOffset > 0 && this.garbageQueue && this.garbageQueue.length > 0) {
                              // æ™‚é–“é †ã«ã‚½ãƒ¼ãƒˆï¼ˆå¿µã®ãŸã‚ï¼‰
                              this.garbageQueue.sort((a, b) => a.time - b.time);
                              
                              for (let i = 0; i < this.garbageQueue.length; i++) {
                                  if (remainingOffset <= 0) break;
                                  
                                  const item = this.garbageQueue[i];
                                  if (item.amount <= remainingOffset) {
                                      // ã¾ã‚‹ã”ã¨ç›¸æ®º
                                      remainingOffset -= item.amount;
                                      this.garbageQueue.splice(i, 1);
                                      i--; // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹èª¿æ•´
                                  } else {
                                      // ä¸€éƒ¨åˆ†ç›¸æ®º
                                      item.amount -= remainingOffset;
                                      remainingOffset = 0;
                                  }
                              }
                          }

                          // ä½™ã£ãŸåˆ†ã‚’ç›¸æ‰‹ã«é€ã‚‹
                          if (remainingOffset > 0) {
                              this.sendGarbage(remainingOffset, positions);
                          }
                          
                          // äºˆå‘Šã‚²ãƒ¼ã‚¸æ›´æ–°
                          this.updateGarbageGauge();
                      }

                      await this.applyGravity();
                      await this.delay(50);
                  }
              }
          }

          findMatches() {
              const visited = Array(ROWS).fill().map(() => Array(COLS).fill(false));
              const allMatches = [];

              for (let row = 0; row < ROWS; row++) {
                  for (let col = 0; col < COLS; col++) {
                      if (this.grid[row][col] && this.grid[row][col].active && !visited[row][col]) {
                          const puyo = this.grid[row][col];
                          // ãŠã˜ã‚ƒã¾ã·ã‚ˆï¼ˆgrayï¼‰ã¯è‡ªåˆ†ã‹ã‚‰ã¯æ¶ˆãˆãªã„
                          if (puyo.getData('color') === 'gray') continue;

                          const group = this.floodFill(row, col, visited);
                          if (group.length >= 4) {
                              allMatches.push(...group);
                              
                              // éš£æ¥ã™ã‚‹ãŠã˜ã‚ƒã¾ã·ã‚ˆã‚’å·»ãè¾¼ã¿æ¶ˆå»
                              group.forEach(p => {
                                  const neighbors = [
                                      {r: p.row-1, c: p.col}, {r: p.row+1, c: p.col},
                                      {r: p.row, c: p.col-1}, {r: p.row, c: p.col+1}
                                  ];
                                  neighbors.forEach(n => {
                                      if (n.r >= 0 && n.r < ROWS && n.c >= 0 && n.c < COLS) {
                                          const neighborPuyo = this.grid[n.r][n.c];
                                          if (neighborPuyo && neighborPuyo.active && neighborPuyo.getData('color') === 'gray') {
                                              // ã¾ã è¿½åŠ ã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿è¿½åŠ 
                                              const alreadyAdded = allMatches.some(m => m.row === n.r && m.col === n.c);
                                              if (!alreadyAdded) {
                                                  allMatches.push({ row: n.r, col: n.c, isGarbage: true });
                                              }
                                          }
                                      }
                                  });
                              });
                          }
                      }
                  }
              }

              return allMatches;
          }

          floodFill(startRow, startCol, visited) {
              const startPuyo = this.grid[startRow][startCol];
              if (!startPuyo || !startPuyo.active) return [];

              const color = startPuyo.getData('color');
              if (!color || color === 'gray') return [];

              const group = [];
              const stack = [[startRow, startCol]];

              while (stack.length > 0) {
                  const [row, col] = stack.pop();

                  if (row < 0 || row >= ROWS || col < 0 || col >= COLS) continue;
                  if (visited[row][col]) continue;

                  const puyo = this.grid[row][col];
                  if (!puyo || !puyo.active || puyo.getData('color') !== color) continue;

                  visited[row][col] = true;
                  group.push({ row, col });

                  stack.push([row - 1, col], [row + 1, col], [row, col - 1], [row, col + 1]);
              }

              return group;
          }

          async clearPuyos(matches) {
              return new Promise(resolve => {
                  const uniqueMatches = [];
                  const seen = new Set();

                  for (const m of matches) {
                      const key = `${m.row},${m.col}`;
                      if (!seen.has(key)) {
                          seen.add(key);
                          uniqueMatches.push(m);
                      }
                  }

                  const sprites = [];

                  for (const m of uniqueMatches) {
                      if (this.grid[m.row] && this.grid[m.row][m.col]) {
                          const sprite = this.grid[m.row][m.col];
                          if (sprite && sprite.active && sprite.scene) {
                              sprites.push(sprite);
                          }
                      }
                  }

                  if (sprites.length === 0) {
                      resolve();
                      return;
                  }

                  for (const m of uniqueMatches) {
                      if (this.grid[m.row] && this.grid[m.row][m.col]) {
                          this.grid[m.row][m.col] = null;
                      }
                  }

                  if (this.chainCount > 1) {
                      try {
                          this.cameras.main.shake(100, 0.002 * this.chainCount);
                      } catch (e) {}
                  }

                  sprites.forEach((sprite, index) => {
                      if (!sprite || !sprite.active || !sprite.scene) return;

                      const color = sprite.getData('color');
                      const x = sprite.x;
                      const y = sprite.y;

                      for (let i = 0; i < 8; i++) {
                          const angle = (i / 8) * Math.PI * 2;
                          const distance = 40 + Math.random() * 20;

                          try {
                              const particle = this.add.circle(x, y, 6, COLOR_VALUES[color]);
                              this.tweens.add({
                                  targets: particle,
                                  x: x + Math.cos(angle) * distance,
                                  y: y + Math.sin(angle) * distance,
                                  alpha: 0,
                                  scale: 0.2,
                                  duration: 500 + Math.random() * 200,
                                  ease: 'Power2',
                                  onComplete: () => {
                                      try {
                                          if (particle && particle.scene) particle.destroy();
                                      } catch (e) {}
                                  }
                              });
                          } catch (e) {}
                      }

                      try {
                          const ring = this.add.circle(x, y, 10, 0xffffff, 0.8);
                          this.tweens.add({
                              targets: ring,
                              radius: 40,
                              alpha: 0,
                              duration: 400,
                              onComplete: () => {
                                  try {
                                      if (ring && ring.scene) ring.destroy();
                                  } catch (e) {}
                              }
                          });
                      } catch (e) {}
                  });

                  try {
                      this.tweens.add({
                          targets: sprites,
                          scale: { from: 1, to: 0 },
                          alpha: { from: 1, to: 0 },
                          duration: 400,
                          ease: 'Back.easeIn',
                          onComplete: () => {
                              sprites.forEach(sprite => {
                                  try {
                                      if (sprite && sprite.scene) {
                                          this.tweens.killTweensOf(sprite);
                                          sprite.destroy();
                                      }
                                  } catch (e) {}
                              });
                              
                              // å‰Šé™¤ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é€ä¿¡
                              if (ws && ws.readyState === WebSocket.OPEN) {
                                  const positions = uniqueMatches.map(m => ({ row: m.row, col: m.col }));
                                  ws.send(JSON.stringify({
                                      type: 'clear_animation',
                                      data: {
                                          positions: positions,
                                          chainCount: this.chainCount
                                      }
                                  }));
                              }
                              
                              resolve();
                          }
                      });
                  } catch (e) {
                      sprites.forEach(sprite => {
                          try {
                              if (sprite && sprite.scene) {
                                  this.tweens.killTweensOf(sprite);
                                  sprite.destroy();
                              }
                          } catch (e) {}
                      });
                      resolve();
                  }
              });
          }

          async applyGravity() {
              let moved = true;

              while (moved) {
                  moved = false;
                  for (let row = ROWS - 2; row >= 0; row--) {
                      for (let col = 0; col < COLS; col++) {
                          if (this.grid[row][col] && !this.grid[row + 1][col]) {
                              this.grid[row + 1][col] = this.grid[row][col];
                              this.grid[row][col] = null;

                              this.tweens.add({
                                  targets: this.grid[row + 1][col],
                                  y: (row + 1) * CELL_SIZE + CELL_SIZE / 2,
                                  duration: 150,
                                  ease: 'Bounce.easeOut'
                              });

                              moved = true;
                          }
                      }
                  }
                  if (moved) await this.delay(150);
              }
          }

          delay(ms) {
              return new Promise(resolve => this.time.delayedCall(ms, resolve));
          }

          updateGarbageGauge() {
              // å…¨å¾…æ©ŸãŠã˜ã‚ƒã¾ã·ã‚ˆæ•°ã‚’è¨ˆç®—
              let totalGarbage = this.pendingGarbageCount;
              if (this.garbageQueue) {
                  totalGarbage += this.garbageQueue.reduce((sum, item) => sum + item.amount, 0);
              }

              // äºˆå‘Šã‚²ãƒ¼ã‚¸ã®é«˜ã•ã‚’æ›´æ–°
              const maxGarbage = 30;  // æœ€å¤§è¡¨ç¤ºæ•°
              const ratio = Math.min(totalGarbage / maxGarbage, 1);
              const gaugeHeight = ROWS * CELL_SIZE * ratio;
              
              this.garbageGauge.setSize(20, gaugeHeight);
              
              // æ•°å€¤è¡¨ç¤º
              if (totalGarbage > 0) {
                  this.garbageCountText.setText(`${totalGarbage}`);
              } else {
                  this.garbageCountText.setText('');
              }
          }

          sendFieldUpdate() {
              if (ws && ws.readyState === WebSocket.OPEN) {
                  const gridData = [];
                  for (let row = 0; row < ROWS; row++) {
                      gridData[row] = [];
                      for (let col = 0; col < COLS; col++) {
                          if (this.grid[row][col] && this.grid[row][col].active) {
                              gridData[row][col] = this.grid[row][col].getData('color');
                          } else {
                              gridData[row][col] = null;
                          }
                      }
                  }

                  ws.send(JSON.stringify({
                      type: 'game_update',
                      gameState: gridData
                  }));
              }
          }

          sendGarbage(amount, sourcePositions) {
              if (ws && ws.readyState === WebSocket.OPEN) {
                  const colors = [];
                  for (let i = 0; i < amount; i++) {
                      colors.push('gray');
                  }

                  // è‡ªåˆ†ã®æ”»æ’ƒãŒç›¸æ‰‹ã«é£›ã‚“ã§ã„ãã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                  sourcePositions.slice(0, amount).forEach((pos, i) => {
                      const startX = pos.x;
                      const startY = pos.y;
                      
                      const particle = this.add.circle(startX, startY, CELL_SIZE * 0.25, 0x888888, 0.9);
                      particle.setDepth(200);

                      const targetX = Phaser.Math.Between(0, this.cameras.main.width);
                      const targetY = -100;

                      this.tweens.add({
                          targets: particle,
                          x: targetX,
                          y: targetY,
                          scale: 0.5,
                          alpha: 0,
                          duration: 800,
                          delay: i * 30,
                          ease: 'Power2',
                          onComplete: () => particle.destroy()
                      });
                  });

                  ws.send(JSON.stringify({
                      type: 'send_garbage',
                      amount: amount,
                      colors: colors,
                      positions: sourcePositions
                  }));
              }
          }

          receiveGarbage(fromPlayerId, amount, colors, sourcePositions) {
              // æ”»æ’ƒå…ƒã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å–å¾—
              const sourceField = this.opponentFields.get(fromPlayerId);
              if (!sourceField) return;

              // ãŠã˜ã‚ƒã¾ã·ã‚ˆã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ  (4ç§’å¾Œã«æœ‰åŠ¹åŒ–)
              this.garbageQueue.push({
                  amount: amount,
                  time: this.time.now + 3000
              });
              this.updateGarbageGauge();

              // æ”»æ’ƒå…ƒã‹ã‚‰è‡ªåˆ†ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¸é£›ã‚“ã§ãã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
              sourcePositions.slice(0, amount).forEach((pos, i) => {
                  // ç›¸æ‰‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´ã•ã‚ŒãŸä½ç½®ã‹ã‚‰é£›ã°ã™
                  const sourceX = sourceField.x + sourceField.width / 2;
                  const sourceY = sourceField.y + sourceField.height / 2;

                  const particle = this.add.circle(sourceX, sourceY, CELL_SIZE * 0.25, 0x888888, 0.9);
                  particle.setDepth(200);

                  // è‡ªåˆ†ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ä¸Šéƒ¨ã¸
                  const targetX = this.fieldOffsetX + COLS * CELL_SIZE / 2;
                  const targetY = -50;

                  this.tweens.add({
                      targets: particle,
                      x: targetX,
                      y: targetY,
                      scale: 0.8,
                      alpha: 0.6,
                      duration: 600,
                      delay: i * 50,
                      ease: 'Power2',
                      onComplete: () => {
                          particle.destroy();
                      }
                  });
              });
          }

          showThirdPartyAttack(fromPlayerId, toPlayerId, amount, sourcePositions) {
              const fromField = this.opponentFields.get(fromPlayerId);
              const toField = this.opponentFields.get(toPlayerId);
              
              if (!fromField || !toField) return;
              
              sourcePositions.slice(0, Math.min(amount, 10)).forEach((pos, i) => {
                  const sourceX = fromField.x + fromField.width / 2;
                  const sourceY = fromField.y + fromField.height / 2;
                  
                  const targetX = toField.x + toField.width / 2;
                  const targetY = toField.y + toField.height / 2;
                  
                  const particle = this.add.circle(sourceX, sourceY, CELL_SIZE * 0.2, 0x888888, 0.7);
                  particle.setDepth(200);
                  
                  this.tweens.add({
                      targets: particle,
                      x: targetX,
                      y: targetY,
                      scale: 0.5,
                      alpha: 0,
                      duration: 500,
                      delay: i * 30,
                      ease: 'Power2',
                      onComplete: () => particle.destroy()
                  });
              });
          }
          
          showOpponentHardDrop(playerId, data) {
              const field = this.opponentFields.get(playerId);
              if (!field) return;
              
              const startY = field.y + data.startRow * CELL_SIZE * field.scale + (CELL_SIZE * field.scale) / 2;
              const endY = field.y + data.endRow * CELL_SIZE * field.scale + (CELL_SIZE * field.scale) / 2;
              const x = field.x + data.col * CELL_SIZE * field.scale + (CELL_SIZE * field.scale) / 2;
              
              for (let i = 0; i < 5; i++) {
                  const trail = this.add.circle(
                      x,
                      startY + (endY - startY) * (i / 5),
                      CELL_SIZE * 0.3 * field.scale,
                      COLOR_VALUES[data.color],
                      0.3 - i * 0.05
                  );
                  trail.setDepth(field.bg.depth + 50);
                  this.tweens.add({
                      targets: trail,
                      alpha: 0,
                      duration: 200,
                      delay: i * 20,
                      onComplete: () => trail.destroy()
                  });
              }
          }
          
          showOpponentClear(playerId, data) {
              const field = this.opponentFields.get(playerId);
              if (!field) return;
              
              // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚’ä¿å­˜
              const spritesToAnimate = [];
              
              data.positions.forEach((pos) => {
                  const puyo = field.grid[pos.row] && field.grid[pos.row][pos.col];
                  if (!puyo) return;
                  
                  const color = puyo.getData('color');
                  const x = puyo.x;
                  const y = puyo.y;
                  
                  // ã‚°ãƒªãƒƒãƒ‰ã‹ã‚‰å³åº§ã«å‰Šé™¤ï¼ˆé…å»¶ã‚’æ¸›ã‚‰ã™ï¼‰
                  field.grid[pos.row][pos.col] = null;
                  
                  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã«ä¿å­˜
                  spritesToAnimate.push({ puyo, color, x, y });
              });
              
              // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
              spritesToAnimate.forEach(({ puyo, color, x, y }) => {
                  for (let i = 0; i < 8; i++) {
                      const angle = (i / 8) * Math.PI * 2;
                      const distance = (40 + Math.random() * 20) * field.scale;
                      
                      const particle = this.add.circle(x, y, 6 * field.scale, COLOR_VALUES[color]);
                      if (field.bg) {
                          particle.setDepth(field.bg.depth + 100);
                      }
                      this.tweens.add({
                          targets: particle,
                          x: x + Math.cos(angle) * distance,
                          y: y + Math.sin(angle) * distance,
                          alpha: 0,
                          scale: 0.2,
                          duration: 500 + Math.random() * 200,
                          ease: 'Power2',
                          onComplete: () => particle.destroy()
                      });
                  }
                  
                  const ring = this.add.circle(x, y, 10 * field.scale, 0xffffff, 0.8);
                  if (field.bg) {
                      ring.setDepth(field.bg.depth + 100);
                  }
                  this.tweens.add({
                      targets: ring,
                      radius: 40 * field.scale,
                      alpha: 0,
                      duration: 400,
                      onComplete: () => ring.destroy()
                  });
                  
                  // ã·ã‚ˆæœ¬ä½“ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§æ¶ˆã™
                  this.tweens.add({
                      targets: puyo,
                      scale: 0,
                      alpha: 0,
                      duration: 400,
                      ease: 'Back.easeIn',
                      onComplete: () => {
                          if (puyo && puyo.scene) puyo.destroy();
                      }
                  });
              });
          }

          async dropGarbagePuyos() {
              if (this.pendingGarbageCount === 0) return;

              const garbageToDrop = this.pendingGarbageCount;
              this.pendingGarbageCount = 0;
              this.updateGarbageGauge();

              for (let i = 0; i < garbageToDrop; i++) {
                  const col = Phaser.Math.Between(0, COLS - 1);
                  const startY = -CELL_SIZE;
                  const x = this.fieldOffsetX + col * CELL_SIZE + CELL_SIZE / 2;

                  let targetRow = 0;
                  for (let row = ROWS - 1; row >= 0; row--) {
                      if (!this.grid[row][col]) {
                          targetRow = row;
                          break;
                      }
                  }

                  const puyo = this.createPuyo(x, startY, 'gray');  // å¸¸ã«gray
                  this.grid[targetRow][col] = puyo;

                  this.tweens.add({
                      targets: puyo,
                      y: targetRow * CELL_SIZE + CELL_SIZE / 2,
                      duration: 300 + targetRow * 30,
                      ease: 'Bounce.easeOut'
                  });

                  await this.delay(150);
              }

              await this.delay(300);
              await this.applyGravity();
              this.checkBorderLine();
          }

          checkBorderLine() {
              let isDanger = false;
              // BORDER_LINEã‚’è¶…ãˆã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ (index < BORDER_LINE)
              // BORDER_LINE (index 4) ã«ã·ã‚ˆãŒã‚ã‚‹ã®ã¯ã‚»ãƒ¼ãƒ•
              // grid[3]ä»¥ä¸‹ã«ã·ã‚ˆãŒã‚ã‚‹ã¨ã‚¢ã‚¦ãƒˆ
              for (let col = 0; col < COLS; col++) {
                   if (this.grid[BORDER_LINE - 1][col] !== null) {
                       isDanger = true;
                       break;
                   }
              }

              if (isDanger) {
                  if (!this.defeatTimer && !this.gameOver) {
                      // è¨­å®šã•ã‚ŒãŸæ™‚é–“ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ10ç§’ï¼‰
                      const defeatTime = (this.gameSettings && this.gameSettings.defeatTime) ? this.gameSettings.defeatTime : 10;
                      
                      // ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹
                      this.defeatTimer = this.time.delayedCall(defeatTime * 1000, () => {
                          this.endGame();
                      });
                      // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³è¡¨ç¤ºã¯updateã§åˆ¶å¾¡
                      this.defeatCountdownText.setVisible(true);
                      
                      // æ ã‚’èµ¤ãã™ã‚‹
                      if (this.myFieldBorder) {
                          this.myFieldBorder.setStrokeStyle(4, 0xff0000);
                      }
                  }
              } else {
                  // è§£é™¤
                  if (this.defeatTimer) {
                      this.defeatTimer.remove();
                      this.defeatTimer = null;
                      this.defeatCountdownText.setVisible(false);
                      
                      // æ ã‚’å…ƒã«æˆ»ã™
                      if (this.myFieldBorder) {
                          this.myFieldBorder.setStrokeStyle(4, 0x2c3e50);
                      }
                  }
              }
          }

          handlePlayerDefeated(playerId) {
              // æ•—åŒ—ã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å´©å£Šã•ã›ã‚‹
              const field = this.opponentFields.get(playerId);
              if (!field) return;

              this.collapseField(field);

              // ç”Ÿå­˜ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤
              this.alivePlayers = this.alivePlayers.filter(id => id !== playerId);

              // 1v1ã«ãªã£ãŸã‹ç¢ºèª
              if (this.alivePlayers.length === 2) {
                  this.switchTo1v1();
              }
          }

          collapseField(field) {
              // æ ã®ç ´è£‚ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
              if (field.border) {
                  // æ ã‚’è¤‡æ•°ã®ç ´ç‰‡ã«è¦‹ç«‹ã¦ã¦ç ´è£‚ã•ã›ã‚‹
                  for (let i = 0; i < 12; i++) {
                      const angle = (i / 12) * Math.PI * 2;
                      const dist = 100 + Math.random() * 100;
                      
                      const fragment = this.add.rectangle(
                          field.x + field.width / 2, 
                          field.y + field.height / 2, 
                          20, 4, 0x2c3e50
                      );
                      fragment.setDepth(1500);
                      fragment.setRotation(angle);

                      this.tweens.add({
                          targets: fragment,
                          x: fragment.x + Math.cos(angle) * dist,
                          y: fragment.y + Math.sin(angle) * dist,
                          angle: Phaser.Math.Between(-360, 360),
                          alpha: 0,
                          scale: 2,
                          duration: 1200,
                          ease: 'Power2',
                          onComplete: () => fragment.destroy()
                      });
                  }

                  this.tweens.add({
                      targets: field.border,
                      scale: 1.5,
                      alpha: 0,
                      duration: 500,
                      ease: 'Expo.easeOut',
                      onComplete: () => {
                          if (field.border) field.border.destroy();
                      }
                  });
              }
              
              // ç”»é¢æŒ¯å‹• (å¤§)
              this.cameras.main.shake(400, 0.02);

              // èƒŒæ™¯ã¨ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®å´©å£Š
              if (field.bg) {
                  this.tweens.add({
                      targets: field.bg,
                      alpha: 0,
                      scaleY: 0,
                      duration: 1000,
                      ease: 'Power2',
                      onComplete: () => {
                          if (field.bg) {
                              field.bg.destroy();
                              field.bg = null;
                          }
                      }
                  });
              }
              
              // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ç”»åƒã‚‚ç ´å£Š
              if (field.gradient) {
                  this.tweens.add({
                      targets: field.gradient,
                      alpha: 0,
                      duration: 1000,
                      ease: 'Power2',
                      onComplete: () => {
                          if (field.gradient) {
                              field.gradient.destroy();
                              field.gradient = null;
                          }
                      }
                  });
              }

              // ã·ã‚ˆã‚’ãƒãƒ©ãƒãƒ©ã«å´©ã™ (çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¿½åŠ )
              for (let row = 0; row < ROWS; row++) {
                  for (let col = 0; col < COLS; col++) {
                      if (field.grid[row][col]) {
                          const puyo = field.grid[row][col];
                          const angle = Phaser.Math.Between(0, 360);
                          const distance = Phaser.Math.Between(100, 300); // è·é›¢å¢—åŠ 
                          
                          // çˆ†ç™ºãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                          for (let i = 0; i < 5; i++) { // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¢—åŠ 
                              const pData = puyo.getData('color') || 'gray';
                              const pColor = COLOR_VALUES[pData];
                              const p = this.add.circle(puyo.x, puyo.y, 4, pColor, 1);
                              const pAngle = Phaser.Math.Between(0, 360);
                              const pDist = Phaser.Math.Between(50, 250);
                              
                              this.tweens.add({
                                  targets: p,
                                  x: puyo.x + Math.cos(pAngle) * pDist,
                                  y: puyo.y + Math.sin(pAngle) * pDist,
                                  alpha: 0,
                                  duration: 1000,
                                  ease: 'Power2',
                                  onComplete: () => p.destroy()
                              });
                          }

                          this.tweens.add({
                              targets: puyo,
                              x: puyo.x + Math.cos(angle) * distance,
                              y: puyo.y + Math.sin(angle) * distance,
                              angle: Phaser.Math.Between(-720, 720),
                              alpha: 0,
                              scale: 0,
                              duration: 1500 + Math.random() * 500, // æ™‚é–“å»¶é•·
                              delay: (row + col) * 10,
                              ease: 'Power2',
                              onComplete: () => {
                                  if (puyo && puyo.scene) puyo.destroy();
                              }
                          });
                      }
                  }
              }

              // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
              if (field.name) {
                  this.tweens.add({
                      targets: field.name,
                      alpha: 0,
                      duration: 800,
                      onComplete: () => {
                          if (field.name) field.name.destroy();
                      }
                  });
              }
          }

          switchTo1v1() {
               if (this.is1v1Mode) return;
               this.is1v1Mode = true;
               console.log('Switching to 1v1 mode layout');
               
               // ç¾åœ¨ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä½ç½®ï¼ˆè‡ªåˆ†ï¼‰
               const oldFieldX = this.fieldOffsetX;
               
               // æ–°ã—ã„ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—
               const fieldWidth = COLS * CELL_SIZE;
               const totalWidth = fieldWidth * 2 + 100;
               const newFieldX = (1000 - totalWidth) / 2;
               const diffX = newFieldX - oldFieldX;
               
               this.fieldOffsetX = newFieldX;
               
               // èƒŒæ™¯ãƒ»æ ã®å†ç”Ÿæˆã®ãŸã‚ã€æ—¢å­˜ã®myFieldã‚¿ã‚°ä»˜ãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤
               // (ãŸã ã—ã‚°ãƒªãƒƒãƒ‰å†…ã®ã·ã‚ˆã¯æ®‹ã™)
               const children = this.children.list.slice(); // ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆ
               children.forEach(child => {
                   if (child.getData('myField') || child.getData('myFieldBorder')) {
                       child.destroy();
                   }
               });
               
               // æ–°ã—ã„ä½ç½®ã§è‡ªåˆ†ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ ç”Ÿæˆ
               this.createField(newFieldX, 'YOU');
               this.scoreText.setPosition(newFieldX, ROWS * CELL_SIZE + 20);
               this.chainText.setPosition(newFieldX + COLS * CELL_SIZE / 2, ROWS * CELL_SIZE / 2);
               this.nextContainer.setPosition(newFieldX + 30, 50);
     
     // äºˆå‘Šã‚²ãƒ¼ã‚¸ã®ä½ç½®æ›´æ–°
     if (this.garbageGaugeBg) {
         this.garbageGaugeBg.setPosition(newFieldX + COLS * CELL_SIZE + 15, ROWS * CELL_SIZE / 2);
     }
     if (this.garbageGauge) {
         this.garbageGauge.setPosition(newFieldX + COLS * CELL_SIZE + 15, ROWS * CELL_SIZE / 2);
     }
     if (this.garbageCountText) {
         this.garbageCountText.setPosition(newFieldX + COLS * CELL_SIZE + 25, ROWS * CELL_SIZE / 2 - ROWS * CELL_SIZE / 2 - 20);
     }
     if (this.comboText) {
         this.comboText.setPosition(newFieldX + COLS * CELL_SIZE / 2, ROWS * CELL_SIZE / 2 + 40);
     }
               if (this.defeatCountdownText) {
                    this.defeatCountdownText.setPosition(
                        newFieldX + COLS * CELL_SIZE / 2,
                        ROWS * CELL_SIZE / 2
                    );
               }

               // è‡ªåˆ†ã®ã·ã‚ˆã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚’ç§»å‹•
               for (let row = 0; row < ROWS; row++) {
                   for (let col = 0; col < COLS; col++) {
                       if (this.grid[row][col]) {
                           this.grid[row][col].x += diffX;
                       }
                   }
               }
               // æ“ä½œä¸­ã®ãƒšã‚¢ã‚‚ç§»å‹•
               if (this.currentPair) {
                   if (this.currentPair.main.sprite) this.currentPair.main.sprite.x += diffX;
                   if (this.currentPair.sub.sprite) this.currentPair.sub.sprite.x += diffX;
                   this.updateGhostPieces(); // ã‚´ãƒ¼ã‚¹ãƒˆå†æç”»
               }
               
               // ç›¸æ‰‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®æ›´æ–° (æ®‹ã‚Š1äººã®ã¯ãš)
               // æ—¢å­˜ã®ç›¸æ‰‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æƒ…å ±ã‚’å–å¾—ã—ã¦å‰Šé™¤
               this.opponentFields.forEach((field, pid) => {
                   if (field.bg) field.bg.destroy();
                   if (field.border) field.border.destroy();
                   if (field.name) field.name.destroy();
                   // ã‚°ãƒªãƒƒãƒ‰ã®ã·ã‚ˆã‚‚ä¸€æ—¦å‰Šé™¤ï¼ˆæ¬¡ã®æ›´æ–°ã§å†æç”»ã•ã‚Œã‚‹ãŒã€ä½ç½®ãŒãšã‚Œã‚‹ã®ã§æ¶ˆã—ã¦ãŠãï¼‰
                   for(let r=0; r<ROWS; r++){
                       for(let c=0; c<COLS; c++){
                           if(field.grid[r][c]) field.grid[r][c].destroy();
                       }
                   }
                   if (field.pieceContainer) field.pieceContainer.destroy();
               });
               this.opponentFields.clear();
               
               // æ®‹ã£ã¦ã„ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å¯¾ã—ã¦createOpponentFieldsã‚’å‘¼ã¶
               // alivePlayersã¯æ—¢ã«æ›´æ–°ã•ã‚Œã¦ã„ã‚‹ã¯ãš
               const opponents = this.players.filter(p => this.alivePlayers.includes(p.id) && p.id !== myPlayerId);
               this.createOpponentFields(opponents); // ã“ã‚Œã§1v1é…ç½®ã«ãªã‚‹ã¯ãš
          }

          sendPieceUpdate() {
              if (ws && ws.readyState === WebSocket.OPEN && this.currentPair) {
                  ws.send(JSON.stringify({
                      type: 'piece_update',
                      data: {
                          col: this.currentPair.col,
                          row: this.currentPair.row,
                          rotation: this.currentPair.rotation,
                          colors: {
                              main: this.currentPair.main.color,
                              sub: this.currentPair.sub.color
                          }
                      }
                  }));
              }
          }

          updateOpponentPiece(playerId, data) {
              const field = this.opponentFields.get(playerId);
              if (!field) return;
              
              // å‰å›ã®ãƒ”ãƒ¼ã‚¹è¡¨ç¤ºã‚’å‰Šé™¤
              if (!field.pieceContainer) {
                  field.pieceContainer = this.add.container(0, 0);
              }
              field.pieceContainer.removeAll(true);
              
              // ç›¸æ‰‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä¸Šã®åº§æ¨™è¨ˆç®—
              const positions = this.getPairPositions(data.col, data.row, data.rotation);
              
              // æç”» (åŠé€æ˜ã§è¡¨ç¤ºã€ã‚¹ã‚±ãƒ¼ãƒ«å¯¾å¿œ)
              const drawPiece = (pos, color) => {
                  if (pos.row < 0) return; // ç”»é¢å¤–
                  const x = field.x + pos.col * CELL_SIZE * field.scale + (CELL_SIZE * field.scale) / 2;
                  const y = field.y + pos.row * CELL_SIZE * field.scale + (CELL_SIZE * field.scale) / 2;
                  
                  const puyo = this.add.circle(x, y, CELL_SIZE * 0.38 * field.scale, COLOR_VALUES[color], 0.6);
                  puyo.setStrokeStyle(2 * field.scale, 0xffffff, 0.5);
                  puyo.setDepth(field.bg.depth + 10);
                  field.pieceContainer.add(puyo);
              };
              
              drawPiece(positions.main, data.colors.main);
              drawPiece(positions.sub, data.colors.sub);
          }

          handleGameEnd(winnerId, isWinner) {
              this.gameOver = true;
              if (this.dropTimer) this.dropTimer.remove();
              if (this.defeatTimer) this.defeatTimer.remove();
              this.defeatCountdownText.setVisible(false);

              if (isWinner) {
                  this.showMessage('YOU WIN!');
              } else {
                  // è² ã‘ãŸå ´åˆã¯è‡ªåˆ†ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å´©å£Š
                  this.collapseMyField();
                  this.showMessage('YOU LOSE...');
              }
              
              // è©¦åˆçµ‚äº†ï¼ˆå‹è€…æ±ºå®šï¼‰å¾Œã¯å…¨å“¡ãƒ­ãƒ“ãƒ¼ã¸
              this.time.delayedCall(2000, () => {
                  this.resetGame();
                  returnToLobby();
              });
          }

          collapseMyField() {
              // è‡ªåˆ†ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®æ ã‚’å´©å£Š
              if (this.myFieldBorder) {
                  this.tweens.add({
                      targets: this.myFieldBorder,
                      angle: Phaser.Math.Between(-15, 15),
                      scaleX: 0.8,
                      scaleY: 1.2,
                      alpha: 0,
                      duration: 1000,
                      ease: 'Power2'
                  });
              }
              
              // ç”»é¢æŒ¯å‹•
    // ç”»é¢æŒ¯å‹• (å¤§)
    this.cameras.main.shake(400, 0.03);

              // èƒŒæ™¯ã¨ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å´©å£Š
              this.children.list.forEach(child => {
                  if (child.getData && child.getData('myField')) {
                      this.tweens.add({
                          targets: child,
                          alpha: 0,
                          scaleY: 0,
                          duration: 1000,
                          ease: 'Power2'
                      });
                  }
              });

              // ã·ã‚ˆã‚’ãƒãƒ©ãƒãƒ©ã«
              for (let row = 0; row < ROWS; row++) {
                  for (let col = 0; col < COLS; col++) {
                      if (this.grid[row][col]) {
                          const puyo = this.grid[row][col];
                          const angle = Phaser.Math.Between(0, 360);
                          const distance = Phaser.Math.Between(100, 250);

                          this.tweens.add({
                              targets: puyo,
                              x: puyo.x + Math.cos(angle) * distance,
                              y: puyo.y + Math.sin(angle) * distance,
                              angle: Phaser.Math.Between(-720, 720),
                              alpha: 0,
                              scale: 0,
                              duration: 1000 + Math.random() * 500,
                              delay: (row + col) * 30,
                              ease: 'Power3'
                          });
                      }
                  }
              }
          }

          showMessage(text) {
              const message = this.add.text(
                  this.cameras.main.centerX,
                  this.cameras.main.centerY,
                  text,
                  {
                      fontSize: '48px',
                      fontFamily: '"JetBrains Mono"',
                      fill: '#fff',
                      fontStyle: 'bold',
                      stroke: '#000',
                      strokeThickness: 6
                  }
              ).setOrigin(0.5).setDepth(1000);

              message.setAlpha(0);
              this.tweens.add({
                  targets: message,
                  alpha: 1,
                  scale: 1.3,
                  duration: 600,
                  ease: 'Elastic.easeOut'
              });
          }

          endGame() {
              this.gameOver = true;
              if (this.dropTimer) this.dropTimer.remove();
              if (this.defeatTimer) this.defeatTimer.remove();
              this.defeatCountdownText.setVisible(false);

              this.collapseMyField();

              if (ws && ws.readyState === WebSocket.OPEN) {
                  ws.send(JSON.stringify({
                      type: 'game_over'
                  }));
              }
          }

          resetGame() {
              this.gameStarted = false;
              this.score = 0;
              this.gameOver = false;
              this.isMoving = false;
              this.chainCount = 0;
              this.pendingGarbage = [];
              this.players = [];
              this.alivePlayers = [];

              this.children.removeAll(true);
              this.opponentFields.clear();

              for (let row = 0; row < ROWS; row++) {
                  this.grid[row] = [];
                  for (let col = 0; col < COLS; col++) {
                      this.grid[row][col] = null;
                  }
              }
          }
      }

      let game = null;

      function initGame() {
          if (game) return;

          const config = {
              type: Phaser.WEBGL,
              canvas: document.createElement('canvas'),
              width: 1000,
              height: 700,
              parent: 'game-container',
              backgroundColor: '#ffffff',
              scene: MultiplayerPuyoPuyo,
              render: {
                  antialias: true,
                  pixelArt: false,
                  roundPixels: false,
                  transparent: false,
                  clearBeforeRender: true,
                  preserveDrawingBuffer: false,
                  powerPreference: 'high-performance',
                  batchSize: 2048
              },
              scale: {
                  mode: Phaser.Scale.FIT,
                  autoCenter: Phaser.Scale.CENTER_BOTH,
                  width: 1000,
                  height: 700,
                  parent: 'game-container'
              },
              dom: {
                  createContainer: false
              },
              fps: {
                  target: 120,
                  forceSetTimeOut: false,
                  min: 30,
                  smoothStep: true
              }
          };

          game = new Phaser.Game(config);
      }

      window.addEventListener('load', () => {
          connectWebSocket();
          initGame();
      });
    </script>
  </body>
</html>
