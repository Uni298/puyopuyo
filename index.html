<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <title>„Å∑„Çà„Å∑„Çà „Éê„Éà„É´„É≠„ÉØ„Ç§„Ç¢„É´</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        background: #f8f9fa;
        font-family: 'JetBrains Mono', monospace;
        touch-action: none;
        color: #333;
      }
      #game-container {
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
        border-radius: 20px;
        overflow: hidden;
        max-width: 100%;
        max-height: 100%;
        background: #ffffff;
      }
      canvas {
        display: block;
        margin: 0 auto;
      }

      /* „É≠„Éì„ÉºÁîªÈù¢ */
      #lobby {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 50px;
        border-radius: 24px;
        text-align: center;
        color: #333;
        z-index: 1000;
        min-width: 480px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
        border: 1px solid rgba(0, 0, 0, 0.05);
      }

      #lobby h1 {
        margin-bottom: 40px;
        color: #2c3e50;
        font-weight: 800;
        font-size: 28px;
      }

      .btn {
        background: #4a90e2;
        border: none;
        padding: 16px 32px;
        margin: 12px;
        border-radius: 12px;
        color: white;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 4px 6px rgba(74, 144, 226, 0.3);
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(74, 144, 226, 0.4);
        background: #357abd;
      }

      .btn:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(74, 144, 226, 0.3);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .btn.ready {
        background: #2ecc71;
        box-shadow: 0 4px 6px rgba(46, 204, 113, 0.3);
      }

      .btn.ready:hover {
        background: #27ae60;
        box-shadow: 0 6px 12px rgba(46, 204, 113, 0.4);
      }

      #roomCodeInput {
        padding: 16px;
        font-size: 18px;
        border-radius: 12px;
        border: 2px solid #e1e4e8;
        text-align: center;
        margin: 15px;
        width: 220px;
        text-transform: uppercase;
        transition: border-color 0.2s;
        background: #f8f9fa;
        color: #333;
      }

      #roomCodeInput:focus {
        outline: none;
        border-color: #4a90e2;
        background: #fff;
      }

      #roomCode {
        font-size: 42px;
        font-weight: 800;
        color: #2c3e50;
        margin: 25px 0;
        letter-spacing: 8px;
        font-family: monospace;
      }

      #status {
        margin-top: 25px;
        font-size: 15px;
        color: #666;
        font-weight: 500;
      }

      #playerList {
        margin: 25px 0;
        text-align: left;
        background: #f8f9fa;
        padding: 20px;
        border-radius: 16px;
        border: 1px solid #e1e4e8;
      }

      .player-item {
        padding: 12px 16px;
        margin: 8px 0;
        background: #ffffff;
        border-radius: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.03);
        border: 1px solid #eee;
      }

      .player-item.ready {
        background: #f0fff4;
        border-left: 4px solid #2ecc71;
        border-color: #c6f6d5;
      }

      .player-item.host {
        border-left: 4px solid #f1c40f;
      }

      h3 {
        color: #2c3e50;
        font-size: 16px;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid #e1e4e8;
      }

      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <!-- „É≠„Éì„ÉºÁîªÈù¢ -->
    <div id="lobby">
      <h1>üéÆ „Å∑„Çà„Å∑„Çà „Éê„Éà„É´„É≠„ÉØ„Ç§„Ç¢„É´</h1>

      <div id="mainMenu">
        <button class="btn" onclick="createRoom()">„É´„Éº„É†„Çí‰ΩúÊàê</button>
        <br />
        <input
          type="text"
          id="roomCodeInput"
          placeholder="„É´„Éº„É†„Ç≥„Éº„Éâ"
          maxlength="6"
        />
        <br />
        <button class="btn" onclick="joinRoom()">„É´„Éº„É†„Å´ÂèÇÂä†</button>
      </div>

      <div id="waitingRoom" class="hidden">
        <h2>„É´„Éº„É†„Ç≥„Éº„Éâ</h2>
        <div id="roomCode"></div>

        <div id="playerList"></div>

        <div id="status">„Éó„É¨„Ç§„É§„Éº„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...</div>
        <div id="hostSettings" style="margin: 20px 0; padding: 10px; background: #fff; border-radius: 8px;">
            <div style="margin-bottom: 8px;">
                <label for="garbageRate">„Åä„Åò„ÇÉ„Åæ„É¨„Éº„Éà: </label>
                <input type="number" id="garbageRate" min="0.1" max="5.0" step="0.1" value="1.0" style="width: 60px;"> ÂÄç
            </div>
            <div style="margin-bottom: 8px;">
                <label for="dropSpeed">ËêΩ‰∏ãÈÄüÂ∫¶: </label>
                <input type="number" id="dropSpeed" min="50" max="2000" step="50" value="500" style="width: 60px;"> ms
            </div>
            <div>
                <label for="defeatTime">ÊïóÂåóÁå∂‰∫à: </label>
                <input type="number" id="defeatTime" min="3" max="60" step="1" value="10" style="width: 60px;"> Áßí
            </div>
        </div>

        <button id="readyBtn" class="btn" onclick="toggleReady()">
          Ê∫ñÂÇôÂÆå‰∫Ü
        </button>
        <br />
        <button class="btn" onclick="leaveRoom()">ÈÄÄÂá∫</button>
      </div>
    </div>

    <div id="game-container"></div>

    <script>
      const COLS = 6;
      const ROWS = 14;
      const CELL_SIZE = 40;
      const BORDER_LINE = 4;
      const COLORS = ['red', 'blue', 'green', 'yellow', 'purple'];
      const COLOR_VALUES = {
          'red': 0xff3333,
          'blue': 0x3366ff,
          'green': 0x33cc33,
          'yellow': 0xffcc00,
          'purple': 0xcc33ff,
          'gray': 0x888888
      };

      // WebSocketÊé•Á∂ö
      let ws = null;
      let currentRoom = null;
      let isHost = false;
      let myPlayerId = null;
      let myReady = false;
      let allPlayers = [];

      function connectWebSocket() {
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          ws = new WebSocket(`${protocol}//${window.location.host}`);

          ws.onopen = () => {
              console.log('Connected to server');
          };

          ws.onmessage = (event) => {
              const data = JSON.parse(event.data);
              handleServerMessage(data);
          };

          ws.onclose = () => {
              console.log('Disconnected from server');
              setTimeout(connectWebSocket, 3000);
          };

          ws.onerror = (error) => {
              console.error('WebSocket error:', error);
          };
      }

      function handleServerMessage(data) {
          switch (data.type) {
              case 'room_created':
                  currentRoom = data.roomCode;
                  myPlayerId = data.playerId;
                  isHost = true;
                  showWaitingRoom(data.roomCode);
                  
                  // „Éõ„Çπ„ÉàÊ®©ÈôêUIÊõ¥Êñ∞
                  // „Éõ„Çπ„ÉàÊ®©ÈôêUIÊõ¥Êñ∞
                  const updateSettings = () => {
                      if (ws && ws.readyState === WebSocket.OPEN) {
                          ws.send(JSON.stringify({
                              type: 'update_settings',
                              settings: { 
                                  garbageRate: parseFloat(document.getElementById('garbageRate').value),
                                  dropSpeed: parseInt(document.getElementById('dropSpeed').value),
                                  defeatTime: parseInt(document.getElementById('defeatTime').value)
                              }
                          }));
                      }
                  };

                  document.getElementById('garbageRate').disabled = false;
                  document.getElementById('dropSpeed').disabled = false;
                  document.getElementById('defeatTime').disabled = false;
                  
                  document.getElementById('garbageRate').onchange = updateSettings;
                  document.getElementById('dropSpeed').onchange = updateSettings;
                  document.getElementById('defeatTime').onchange = updateSettings;
                  break;

              case 'room_joined':
                  currentRoom = data.roomCode;
                  myPlayerId = data.playerId;
                  isHost = false;
                  showWaitingRoom(data.roomCode);
                  break;

              case 'you_are_host':
                  isHost = true;
                  break;

              case 'room_state':
                  allPlayers = data.players;
                  updatePlayerList(data.players, data.hostId);

                  // ÂÖ®Âì°Ê∫ñÂÇôÂÆå‰∫Ü„ÉÅ„Çß„ÉÉ„ÇØ
                  const allReady = data.players.every(p => p.ready);
                  if (allReady && data.players.length >= 2) {
                      document.getElementById('status').textContent = '„Åæ„ÇÇ„Å™„ÅèÈñãÂßã...';
                  } else if (data.players.length < 2) {
                      document.getElementById('status').textContent = '„Éó„É¨„Ç§„É§„Éº„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô... (ÊúÄ‰Ωé2‰∫∫ÂøÖË¶Å)';
                  } else {
                      document.getElementById('status').textContent = `${data.players.filter(p => p.ready).length}/${data.players.length} ‰∫∫Ê∫ñÂÇôÂÆå‰∫Ü`;
                  }
                  
                  // Ë®≠ÂÆöÂèçÊò†
                  if (data.settings) {
                      const garbageInput = document.getElementById('garbageRate');
                      const dropInput = document.getElementById('dropSpeed');
                      const defeatInput = document.getElementById('defeatTime');
                      
                      if (document.activeElement !== garbageInput) garbageInput.value = data.settings.garbageRate;
                      if (document.activeElement !== dropInput) dropInput.value = data.settings.dropSpeed || 500;
                      if (document.activeElement !== defeatInput) defeatInput.value = data.settings.defeatTime || 10;
                      
                      // „Éõ„Çπ„Éà‰ª•Â§ñ„ÅØÁÑ°ÂäπÂåñ
                      const isMyHost = (data.hostId === myPlayerId);
                      garbageInput.disabled = !isMyHost;
                      dropInput.disabled = !isMyHost;
                      defeatInput.disabled = !isMyHost;
                      
                      // „Éõ„Çπ„ÉàÊ®©ÈôêÊõ¥Êñ∞
                      if (isMyHost) {
                          const updateSettings = () => {
                              if (ws && ws.readyState === WebSocket.OPEN) {
                                  ws.send(JSON.stringify({
                                      type: 'update_settings',
                                      settings: { 
                                          garbageRate: parseFloat(garbageInput.value),
                                          dropSpeed: parseInt(dropInput.value),
                                          defeatTime: parseInt(defeatInput.value)
                                      }
                                  }));
                              }
                          };
                          garbageInput.onchange = updateSettings;
                          dropInput.onchange = updateSettings;
                          defeatInput.onchange = updateSettings;
                      } else {
                          garbageInput.onchange = null;
                          dropInput.onchange = null;
                          defeatInput.onchange = null;
                      }
                  }
                  break;

              case 'game_start':
                  allPlayers = data.players;
                  hideWaitingRoom();
                  if (game && game.scene.scenes[0]) {
                      game.scene.scenes[0].startNewGame(data.players, data.settings);
                  }
                  break;

              case 'error':
                  alert(data.message);
                  break;

              case 'opponent_update':
                  if (game && game.scene.isActive('MultiplayerPuyoPuyo')) {
                      game.scene.scenes[0].updateOpponentField(data.playerId, data.data);
                  }
                  break;

              case 'receive_garbage':
                  if (game && game.scene.isActive('MultiplayerPuyoPuyo')) {
                      game.scene.scenes[0].receiveGarbage(data.fromPlayerId, data.amount, data.colors, data.sourcePositions);
                  }
                  break;

              case 'player_defeated':
                  if (game && game.scene.isActive('MultiplayerPuyoPuyo')) {
                      game.scene.scenes[0].handlePlayerDefeated(data.playerId);
                  }
                  break;

              case 'game_end':
                  if (game && game.scene.isActive('MultiplayerPuyoPuyo')) {
                      game.scene.scenes[0].handleGameEnd(data.winnerId, data.isWinner);
                  }
                  break;

              case 'piece_update':
                  if (game && game.scene.isActive('MultiplayerPuyoPuyo')) {
                      game.scene.scenes[0].updateOpponentPiece(data.playerId, data.data);
                  }
                  break;
          }
      }

      function createRoom() {
          if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'create_room' }));
          }
      }

      function joinRoom() {
          const roomCode = document.getElementById('roomCodeInput').value.toUpperCase();
          if (roomCode.length === 6 && ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({
                  type: 'join_room',
                  roomCode: roomCode
              }));
          } else {
              alert('6Ê°Å„ÅÆ„É´„Éº„É†„Ç≥„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
          }
      }

      function toggleReady() {
          if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'toggle_ready' }));
              myReady = !myReady;

              const btn = document.getElementById('readyBtn');
              if (myReady) {
                  btn.textContent = 'Ê∫ñÂÇôËß£Èô§';
                  btn.classList.add('ready');
              } else {
                  btn.textContent = 'Ê∫ñÂÇôÂÆå‰∫Ü';
                  btn.classList.remove('ready');
              }
          }
      }

      function leaveRoom() {
          if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'leave_room' }));
          }
          location.reload();
      }

      function showWaitingRoom(roomCode) {
          document.getElementById('mainMenu').classList.add('hidden');
          document.getElementById('waitingRoom').classList.remove('hidden');
          document.getElementById('roomCode').textContent = roomCode;
      }

      function hideWaitingRoom() {
          document.getElementById('lobby').classList.add('hidden');
      }

      function returnToLobby() {
          document.getElementById('lobby').classList.remove('hidden');
          myReady = false;
          const btn = document.getElementById('readyBtn');
          btn.textContent = 'Ê∫ñÂÇôÂÆå‰∫Ü';
          btn.classList.remove('ready');
      }

      function updatePlayerList(players, hostId) {
          const list = document.getElementById('playerList');
          list.innerHTML = '<h3>„Éó„É¨„Ç§„É§„Éº‰∏ÄË¶ß</h3>';

          players.forEach(player => {
              const item = document.createElement('div');
              item.className = 'player-item';
              if (player.ready) item.classList.add('ready');
              if (player.id === hostId) item.classList.add('host');

              const name = document.createElement('span');
              name.textContent = player.name;
              if (player.id === hostId) name.textContent += ' üëë';
              if (player.id === myPlayerId) name.textContent += ' („ÅÇ„Å™„Åü)';

              const status = document.createElement('span');
              status.textContent = player.ready ? '‚úÖ Ê∫ñÂÇôÂÆå‰∫Ü' : '‚è≥ ÂæÖÊ©ü‰∏≠';
              status.style.color = player.ready ? '#33cc33' : '#888';

              item.appendChild(name);
              item.appendChild(status);
              list.appendChild(item);
          });
      }

      class MultiplayerPuyoPuyo extends Phaser.Scene {
          constructor() {
              super({ key: 'MultiplayerPuyoPuyo' });
              this.grid = [];
              this.opponentFields = new Map();
              this.currentPair = null;
              this.nextPair = null;
              this.score = 0;
              this.gameOver = false;
              this.isMoving = false;
              this.chainCount = 0;
              this.pendingGarbage = [];
              this.gameStarted = false;
              this.players = [];
              this.alivePlayers = [];
              this.alivePlayers = [];
              this.defeatTimer = null;
              this.defeatCountdownText = null;
              this.is1v1Mode = false;
              this.garbageRate = 1.0;
          }

          preload() {
              this.createGradientTexture();
          }

          createGradientTexture() {
              const graphics = this.add.graphics();
              // „É¢„ÉÄ„É≥„Å™ÁôΩ„Éô„Éº„Çπ„ÅÆ„Åü„ÇÅ„ÄÅËÉåÊôØ„ÅØËñÑ„ÅÑ„Ç∞„É¨„Éº„ÅÆ„Çπ„Éà„É©„Ç§„Éó„Å™„Å©„Å´Â§âÊõ¥„ÄÅ„Åæ„Åü„ÅØÂçòËâ≤
              graphics.fillStyle(0xf0f2f5, 1);
              graphics.fillRect(0, 0, COLS * CELL_SIZE, ROWS * CELL_SIZE);

              // „Ç∞„É™„ÉÉ„ÉâÁ∑ö
              graphics.lineStyle(1, 0xe1e4e8, 1);
              for (let i = 0; i <= ROWS; i++) {
                  graphics.moveTo(0, i * CELL_SIZE);
                  graphics.lineTo(COLS * CELL_SIZE, i * CELL_SIZE);
              }
              for (let i = 0; i <= COLS; i++) {
                  graphics.moveTo(i * CELL_SIZE, 0);
                  graphics.lineTo(i * CELL_SIZE, ROWS * CELL_SIZE);
              }
              graphics.strokePath();

              graphics.generateTexture('gradient', COLS * CELL_SIZE, ROWS * CELL_SIZE);
              graphics.destroy();
          }

          create() {
              // ÂæÖÊ©ü„É°„ÉÉ„Çª„Éº„Ç∏
              this.waitingText = this.add.text(
                  this.cameras.main.centerX,
                  this.cameras.main.centerY,
                  '„Ç≤„Éº„É†ÈñãÂßã„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...',
                  {
                      fontSize: '32px',
                      fontFamily: '"JetBrains Mono"',
                      fill: '#fff',
                      fontStyle: 'bold'
                  }
              ).setOrigin(0.5);

              // „Ç≠„Éº„Éú„Éº„ÉâË®≠ÂÆö
              this.cursors = this.input.keyboard.createCursorKeys();
              this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

              // „Çø„ÉÉ„ÉÅ„Éª„Çπ„ÉØ„Ç§„ÉóË®≠ÂÆö
              this.setupTouchControls();

              this.lastMoveTime = 0;
              this.lastRotateTime = 0;
              this.lockDelayTimer = null;
              this.isOnGround = false;

              // ÊïóÂåó„Çø„Ç§„Éû„ÉºÁî®„ÉÜ„Ç≠„Çπ„Éà
              this.defeatCountdownText = this.add.text(0, 0, '', {
                  fontSize: '64px',
                  fontFamily: '"JetBrains Mono"',
                  fill: '#ff0000',
                  fontStyle: 'bold',
                  stroke: '#ffffff',
                  strokeThickness: 6
              }).setOrigin(0.5).setDepth(1000).setVisible(false);
          }

          startNewGame(players, settings) {
              if (this.gameStarted) return;
              this.gameStarted = true;
              this.players = players;
              this.alivePlayers = players.map(p => p.id);
              this.gameSettings = settings || {};
              this.garbageRate = (this.gameSettings.garbageRate) ? this.gameSettings.garbageRate : 1.0;
              this.zoomedPlayerId = null;

              // ÂæÖÊ©ü„ÉÜ„Ç≠„Çπ„Éà„ÇíÂâäÈô§
              if (this.waitingText) {
                  this.waitingText.destroy();
                  this.waitingText = null;
              }

              // Êó¢Â≠ò„ÅÆË¶ÅÁ¥†„Çí„ÇØ„É™„Ç¢
              this.children.removeAll(true);

              // „Ç≤„Éº„É†Áä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
              this.score = 0;
              this.gameOver = false;
              this.isMoving = false;
              this.chainCount = 0;
              this.pendingGarbage = [];
              if (this.defeatTimer) {
                  this.defeatTimer.remove();
                  this.defeatTimer = null;
              }
              if (this.defeatCountdownText) {
                  this.defeatCountdownText.setVisible(false);
                  this.defeatCountdownText = null; 
              }

              // ÊïóÂåó„Çø„Ç§„Éû„ÉºÁî®„ÉÜ„Ç≠„Çπ„ÉàÂÜçÁîüÊàê
              this.defeatCountdownText = this.add.text(0, 0, '', {
                  fontSize: '64px',
                  fontFamily: '"JetBrains Mono"',
                  fill: '#ff0000',
                  fontStyle: 'bold',
                  stroke: '#ffffff',
                  strokeThickness: 6
              }).setOrigin(0.5).setDepth(1000).setVisible(false);

              // „Ç∞„É™„ÉÉ„Éâ„Çí„ÇØ„É™„Ç¢
              for (let row = 0; row < ROWS; row++) {
                  this.grid[row] = [];
                  for (let col = 0; col < COLS; col++) {
                      this.grid[row][col] = null;
                  }
              }

              this.opponentFields.clear();

              this.opponentFields.clear();
              
              // 1v1„É¢„Éº„ÉâÂà§ÂÆö
              this.is1v1Mode = (players.length === 2);
              
              let offsetX = 50;
              
              if (this.is1v1Mode) {
                  // 1v1„ÅÆÂ†¥Âêà„ÅØÁîªÈù¢‰∏≠Â§Æ„Å´ÂØÑ„Åõ„Çã
                  // „Ç≤„Éº„É†ÂπÖ1000px, „Éï„Ç£„Éº„É´„ÉâÂπÖ COLS*CELL_SIZE + ‰ΩôÁôΩ
                  // Â∑¶„Éï„Ç£„Éº„É´„Éâ: 250px‰ªòËøë, Âè≥„Éï„Ç£„Éº„É´„Éâ: 550px‰ªòËøë
                  const fieldWidth = COLS * CELL_SIZE;
                  const totalWidth = fieldWidth * 2 + 100; // Èñì„ÅÆ„Çπ„Éö„Éº„Çπ100px
                  offsetX = (1000 - totalWidth) / 2;
              }

              // Ëá™ÂàÜ„ÅÆ„Éï„Ç£„Éº„É´„ÉâÔºàÂ∑¶ÂÅ¥Ôºâ
              this.createField(offsetX, 'YOU');
              this.fieldOffsetX = offsetX;

              // Áõ∏Êâã„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÇíÈÖçÁΩÆ
              this.createOpponentFields(players);

              // „Çπ„Ç≥„Ç¢Ë°®Á§∫
              this.scoreText = this.add.text(offsetX, ROWS * CELL_SIZE + 20, 'SCORE: 0', {
                  fontSize: '18px',
                  fontFamily: '"JetBrains Mono"',
                  fill: '#333',
                  fontStyle: 'bold'
              });

              // „ÉÅ„Çß„Ç§„É≥Ë°®Á§∫
              this.chainText = this.add.text(offsetX + COLS * CELL_SIZE / 2, ROWS * CELL_SIZE / 2, '', {
                  fontSize: '28px',
                  fontFamily: '"JetBrains Mono"',
                  fill: '#ffcc00',
                  fontStyle: 'bold'
              }).setOrigin(0.5);

              // NextË°®Á§∫ (Â∑¶ÂÅ¥„Å´ÈÖçÁΩÆ„ÄÅÂ∞ë„Åó‰∏ã„Åí„Çã)
              this.add.text(offsetX - 100, 120, 'NEXT:', {
                  fontSize: '16px',
                  fontFamily: '"JetBrains Mono"',
                  fill: '#333'
              });
              this.nextContainer = this.add.container(offsetX - 70, 150);

              // „Ç≤„Éº„É†ÈñãÂßã
              this.nextPair = this.createPuyoPair();
              this.spawnNewPair();

              if (this.dropTimer) {
                  this.dropTimer.remove();
              }

              const dropDelay = (this.gameSettings && this.gameSettings.dropSpeed) ? this.gameSettings.dropSpeed : 300;
              this.dropTimer = this.time.addEvent({
                  delay: dropDelay,
                  callback: this.autoDrop,
                  callbackScope: this,
                  loop: true
              });
          }

          createField(x, label) {
              // ËÉåÊôØ
              const bg = this.add.rectangle(
                  x + COLS * CELL_SIZE / 2,
                  ROWS * CELL_SIZE / 2,
                  COLS * CELL_SIZE,
                  ROWS * CELL_SIZE,
                  0xffffff
              ).setOrigin(0.5).setDepth(-10);
              bg.setData('myField', true);

              const gradient = this.add.image(x, 0, 'gradient').setOrigin(0).setDepth(-10);
              gradient.setData('myField', true);

              // Êû†
              const border = this.add.rectangle(
                  x + COLS * CELL_SIZE / 2,
                  ROWS * CELL_SIZE / 2,
                  COLS * CELL_SIZE + 4,
                  ROWS * CELL_SIZE + 4,
                  0x000000,
                  0
              ).setOrigin(0.5).setDepth(-5);
              border.setStrokeStyle(4, 0x2c3e50);
              border.setData('myFieldBorder', true);
              this.myFieldBorder = border;

              // „Éú„Éº„ÉÄ„Éº„É©„Ç§„É≥
              const borderY = BORDER_LINE * CELL_SIZE;
              const graphics = this.add.graphics();
              graphics.lineStyle(3, 0xff0000, 0.8);
              graphics.setDepth(100);

              for (let i = 0; i < COLS * CELL_SIZE; i += 10) {
                  if (Math.floor(i / 10) % 2 === 0) {
                      graphics.lineBetween(x + i, borderY, x + Math.min(i + 5, COLS * CELL_SIZE), borderY);
                  }
              }
              graphics.setData('myField', true);

              // „É©„Éô„É´
              this.add.text(x + COLS * CELL_SIZE / 2, -25, label, {
                  fontSize: '20px',
                  fontFamily: '"JetBrains Mono"',
                  fill: '#333',
                  fontStyle: 'bold'
              }).setOrigin(0.5);
          }

          createOpponentFields(players) {
              const opponents = players.filter(p => p.id !== myPlayerId);
              
              if (this.is1v1Mode && opponents.length === 1) {
                   // 1v1„É¢„Éº„Éâ: Áõ∏Êâã„Éï„Ç£„Éº„É´„Éâ„ÇÇËá™ÂàÜ„Å®Âêå„Åò„Çµ„Ç§„Ç∫„ÉªË¶ã„ÅüÁõÆ„ÅßÂè≥ÂÅ¥„Å´ÈÖçÁΩÆ
                   const playerX = this.fieldOffsetX;
                   const opponentX = playerX + COLS * CELL_SIZE + 100; // 100px„ÅÆÈñìÈöî
                   const opponentY = 0; // YÂ∫ßÊ®ô„ÅØÂêå„Åò
                   
                   const field = {
                       x: opponentX,
                       y: opponentY, // createFieldÊ∫ñÊã†„ÅÆYÂ∫ßÊ®ô (0Âü∫Ê∫ñ)
                       width: COLS * CELL_SIZE,
                       height: ROWS * CELL_SIZE,
                       scale: 1.0, 
                       grid: [],
                       border: null,
                       bg: null,
                       name: null,
                       playerId: opponents[0].id,
                       originalProps: null
                   };
                   
                   // „Ç∞„É™„ÉÉ„ÉâÂàùÊúüÂåñ
                   for (let row = 0; row < ROWS; row++) {
                       field.grid[row] = [];
                       for (let col = 0; col < COLS; col++) {
                           field.grid[row][col] = null;
                       }
                   }

                   // ËÉåÊôØ (createField„Å®Âêå„Åò„Çπ„Çø„Ç§„É´)
                   // field.x, field.y„ÅØÂ∑¶‰∏äÂü∫Ê∫ñ„Å®„Åó„Å¶Êâ±„ÅÜ„Åå„ÄÅadd.rectangle„ÅØ‰∏≠ÂøÉÂü∫Ê∫ñ„Å™„ÅÆ„ÅßË™øÊï¥„ÅåÂøÖË¶Å
                   // createField„ÅÆÂÆüË£Ö„ÇíË¶ã„ÇãÈôê„Çä„ÄÅ(x, 0)Ëµ∑ÁÇπ„ÅßÊèèÁîª„Åó„Å¶„ÅÑ„Çã
                   
                   const centerX = opponentX + COLS * CELL_SIZE / 2;
                   const centerY = ROWS * CELL_SIZE / 2;
                   
                   field.bg = this.add.rectangle(
                       centerX,
                       centerY,
                       COLS * CELL_SIZE,
                       ROWS * CELL_SIZE,
                       0xffffff
                   ).setOrigin(0.5).setDepth(-10);
                   field.bg.setData('myField', false); 
                   
                   // „Ç∫„Éº„É†Ê©üËÉΩ„ÅÆ„Åü„ÇÅ„ÅÆ„Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥
                   field.bg.setInteractive();
                   field.bg.on('pointerdown', () => this.toggleZoom(field.playerId));

                   const gradient = this.add.image(opponentX, 0, 'gradient').setOrigin(0).setDepth(-10);
                   
                   // Êû†
                   field.border = this.add.rectangle(
                       centerX,
                       centerY,
                       COLS * CELL_SIZE + 4,
                       ROWS * CELL_SIZE + 4,
                       0x000000,
                       0
                   ).setOrigin(0.5).setDepth(-5);
                   field.border.setStrokeStyle(4, 0x2c3e50);
                   
                   // „Éú„Éº„ÉÄ„Éº„É©„Ç§„É≥ (Ëµ§Á∑ö)
                   const borderY = BORDER_LINE * CELL_SIZE;
                   const graphics = this.add.graphics();
                   graphics.lineStyle(3, 0xff0000, 0.8);
                   graphics.setDepth(100);
                   for (let i = 0; i < COLS * CELL_SIZE; i += 10) {
                       if (Math.floor(i / 10) % 2 === 0) {
                           graphics.lineBetween(opponentX + i, borderY, opponentX + Math.min(i + 5, COLS * CELL_SIZE), borderY);
                       }
                   }
                   
                   // „Éó„É¨„Ç§„É§„ÉºÂêç
                   field.name = this.add.text(centerX, -25, opponents[0].name, {
                       fontSize: '20px',
                       fontFamily: '"JetBrains Mono"',
                       fill: '#333',
                       fontStyle: 'bold'
                   }).setOrigin(0.5);
                   
                   this.opponentFields.set(opponents[0].id, field);
                   
              } else {
                  // ÈÄöÂ∏∏„ÅÆBattle Royale„É¢„Éº„ÉâÔºàÂè≥ÂÅ¥„Å´Â∞è„Åï„Åè‰∏ÄË¶ßË°®Á§∫Ôºâ
                  const startX = 50 + COLS * CELL_SIZE + 80;
                  const fieldWidth = COLS * CELL_SIZE * 0.5;
                  const fieldHeight = ROWS * CELL_SIZE * 0.5;
                  const spacing = 20;
    
                  opponents.forEach((player, index) => {
                      const x = startX;
                      const y = index * (fieldHeight + spacing + 30);
    
                      const field = {
                          x: x,
                          y: y,
                          width: fieldWidth,
                          height: fieldHeight,
                          scale: 0.5,
                          grid: [],
                          border: null,
                          bg: null,
                          name: null,
                          playerId: player.id,
                          originalProps: null
                      };
    
                      // „Ç∞„É™„ÉÉ„ÉâÂàùÊúüÂåñ
                      for (let row = 0; row < ROWS; row++) {
                          field.grid[row] = [];
                          for (let col = 0; col < COLS; col++) {
                              field.grid[row][col] = null;
                          }
                      }
    
                      // ËÉåÊôØ
                      field.bg = this.add.rectangle(
                          x + fieldWidth / 2,
                          y + fieldHeight / 2,
                          fieldWidth,
                          fieldHeight,
                          0xffffff
                      ).setOrigin(0.5);
    
                      // „Ç∫„Éº„É†Ê©üËÉΩ„ÅÆ„Åü„ÇÅ„ÅÆ„Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥
                      field.bg.setInteractive();
                      field.bg.on('pointerdown', () => this.toggleZoom(field.playerId));
    
                      // Êû†
                      field.border = this.add.rectangle(
                          x + fieldWidth / 2,
                          y + fieldHeight / 2,
                          fieldWidth + 2,
                          fieldHeight + 2,
                          0x000000,
                          0
                      ).setOrigin(0.5);
                      field.border.setStrokeStyle(2, 0x95a5a6);
    
                      // „Éó„É¨„Ç§„É§„ÉºÂêç
                      field.name = this.add.text(x + fieldWidth / 2, y - 15, player.name, {
                          fontSize: '14px',
                          fontFamily: '"JetBrains Mono"',
                          fill: '#333',
                          fontStyle: 'bold'
                      }).setOrigin(0.5);
    
                      this.opponentFields.set(player.id, field);
                  });
              }
          }

          updateOpponentField(playerId, gridData) {
              const field = this.opponentFields.get(playerId);
              if (!field) return;

              // Êó¢Â≠ò„ÅÆ„Å∑„Çà„Çí„ÇØ„É™„Ç¢
              for (let row = 0; row < ROWS; row++) {
                  for (let col = 0; col < COLS; col++) {
                      if (field.grid[row][col]) {
                          field.grid[row][col].destroy();
                          field.grid[row][col] = null;
                      }
                  }
              }

              // Êñ∞„Åó„ÅÑ„Éá„Éº„Çø„ÅßÊèèÁîª
              // Êñ∞„Åó„ÅÑ„Éá„Éº„Çø„ÅßÊèèÁîª
              for (let row = 0; row < ROWS; row++) {
                  for (let col = 0; col < COLS; col++) {
                      if (gridData[row][col]) {
                          // ÂÖ®„Éï„Ç£„Éº„É´„ÉâÂÖ±ÈÄö„Åß scale „ÇíËÄÉÊÖÆ„Åó„ÅüÂ∫ßÊ®ôË®àÁÆó„ÇíË°å„ÅÜ
                          const x = field.x + col * CELL_SIZE * field.scale + (CELL_SIZE * field.scale) / 2;
                          const y = field.y + row * CELL_SIZE * field.scale + (CELL_SIZE * field.scale) / 2;
                          field.grid[row][col] = this.createSmallPuyo(x, y, gridData[row][col], field.scale);
                          field.grid[row][col].setDepth(field.bg.depth + 1); // ËÉåÊôØ„ÅÆ„Åô„Åê‰∏ä
                      }
                  }
              }
          }

          toggleZoom(playerId) {
              const field = this.opponentFields.get(playerId);
              if (!field) return;

              if (this.zoomedPlayerId === playerId) {
                  // „Ç∫„Éº„É†Ëß£Èô§
                  if (field.originalProps) {
                     this.tweens.add({
                         targets: field,
                         x: field.originalProps.x,
                         y: field.originalProps.y,
                         scale: field.originalProps.scale,
                         duration: 300,
                         ease: 'Power2',
                         onUpdate: () => {
                             this.updateFieldVisuals(field);
                         },
                         onComplete: () => {
                             field.bg.setDepth(field.originalProps.depth);
                             this.updateFieldVisuals(field); // Âøµ„ÅÆ„Åü„ÇÅ
                         }
                     });
                     
                     // ‰ªñ„ÅÆË¶ÅÁ¥†„ÅÆDepth„ÇÇÊàª„ÅôÂøÖË¶Å„Åå„ÅÇ„Çã„Åå„ÄÅupdateFieldVisuals„Åß„Éô„Éº„ÇπDepth„Åã„Çâ„ÅÆÁõ∏ÂØæÂÄ§„ÅßË®≠ÂÆö„Åô„Çã
                  }
                  this.zoomedPlayerId = null;
              } else {
                  // ‰ªñ„ÅÆ„Éó„É¨„Ç§„É§„Éº„Åå„Ç∫„Éº„É†‰∏≠„Å™„ÇâËß£Èô§
                  if (this.zoomedPlayerId) {
                      this.toggleZoom(this.zoomedPlayerId);
                  }

                  // „Ç∫„Éº„É†ÈñãÂßã
                  field.originalProps = {
                      x: field.x,
                      y: field.y,
                      scale: field.scale,
                      depth: field.bg.depth
                  };

                  const targetScale = 1.0; // Â∏∏„Å´1.0ÂÄçÔºà„Åæ„Åü„ÅØÁîªÈù¢„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Å¶Ë™øÊï¥ÂèØÔºâ
                  const targetX = (this.cameras.main.width - (COLS * CELL_SIZE * targetScale)) / 2;
                  const targetY = (this.cameras.main.height - (ROWS * CELL_SIZE * targetScale)) / 2;
                  const targetDepth = 5000; // ÊúÄÂâçÈù¢

                  field.bg.setDepth(targetDepth);
                  
                  this.tweens.add({
                      targets: field,
                      x: targetX,
                      y: targetY,
                      scale: targetScale,
                      duration: 300,
                      ease: 'Power2',
                      onUpdate: () => {
                          this.updateFieldVisuals(field);
                      }
                  });

                  this.zoomedPlayerId = playerId;
              }
          }

          updateFieldVisuals(field) {
              // ËÉåÊôØ
              const width = COLS * CELL_SIZE * field.scale;
              const height = ROWS * CELL_SIZE * field.scale;
              
              field.bg.setPosition(field.x + width / 2, field.y + height / 2);
              field.bg.setDisplaySize(width, height);
              
              // Êû†
              if (field.border) {
                  field.border.setPosition(field.x + width / 2, field.y + height / 2);
                  field.border.setDisplaySize(width + 4, height + 4);
                  field.border.setDepth(field.bg.depth + 10);
              }

              // ÂêçÂâç
              if (field.name) {
                  field.name.setPosition(field.x + width / 2, field.y - 15 * (field.scale / 0.5)); // „Çπ„Ç±„Éº„É´„Å´Âøú„Åò„Å¶Ë™øÊï¥
                  field.name.setScale(field.scale / 0.5); // ÂÖÉ„Åå0.5„Éô„Éº„Çπ„ÅÆ„Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„Å™„ÇâË™øÊï¥
                  field.name.setDepth(field.bg.depth + 10);
              }

              // „Å∑„Çà (gridÂÜçÈÖçÁΩÆ)
              for (let row = 0; row < ROWS; row++) {
                  for (let col = 0; col < COLS; col++) {
                      const puyo = field.grid[row][col];
                      if (puyo) {
                          const px = field.x + col * CELL_SIZE * field.scale + (CELL_SIZE * field.scale) / 2;
                          const py = field.y + row * CELL_SIZE * field.scale + (CELL_SIZE * field.scale) / 2;
                          puyo.setPosition(px, py);
                          puyo.setScale(field.scale / 1.0); // createSmallPuyo„ÅÆË™øÊï¥Áî®
                          puyo.setRadius(CELL_SIZE * 0.38 * field.scale);
                          puyo.setDepth(field.bg.depth + 1);
                      }
                  }
              }
          }

          createSmallPuyo(x, y, color, scale) {
              const radius = CELL_SIZE * 0.38 * scale;
              const puyo = this.add.circle(x, y, radius, COLOR_VALUES[color], 0.8);
              return puyo;
          }

          setupTouchControls() {
              this.touchStartX = 0;
              this.touchStartY = 0;
              this.touchStartTime = 0;
              this.swipeThreshold = 30;

              this.input.on('pointerdown', (pointer) => {
                  if (this.gameOver) return;
                  this.touchStartX = pointer.x;
                  this.touchStartY = pointer.y;
                  this.touchStartTime = this.time.now;
              });

              this.input.on('pointerup', (pointer) => {
                  if (this.gameOver || !this.currentPair || this.isMoving) return;

                  const deltaX = pointer.x - this.touchStartX;
                  const deltaY = pointer.y - this.touchStartY;
                  const deltaTime = this.time.now - this.touchStartTime;
                  const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                  if (distance < this.swipeThreshold && deltaTime < 300) {
                      this.rotatePair();
                  } else if (distance > this.swipeThreshold) {
                      const angle = Math.atan2(deltaY, deltaX);
                      const absAngle = Math.abs(angle);

                      if (angle > Math.PI / 4 && angle < 3 * Math.PI / 4) {
                          this.hardDrop();
                      } else if (angle < -Math.PI / 4 && angle > -3 * Math.PI / 4) {
                          this.rotatePair();
                      } else if (absAngle < Math.PI / 4) {
                          this.movePair(1);
                      } else if (absAngle > 3 * Math.PI / 4) {
                          this.movePair(-1);
                      }
                  }
              });
          }

          createPuyo(x, y, color, isGhost = false, customAlpha = 1) {
              const puyo = this.add.container(x, y);
              const radius = CELL_SIZE * 0.38;

              const shadow = this.add.circle(2, 2, radius, 0x000000, 0.3);
              puyo.add(shadow);

              const baseColor = COLOR_VALUES[color];
              const body = this.add.circle(0, 0, radius, baseColor);
              puyo.add(body);

              const darkPart = this.add.circle(0, radius * 0.2, radius * 0.9,
                  Phaser.Display.Color.IntegerToColor(baseColor).darken(15).color);
              puyo.add(darkPart);

              const highlight1 = this.add.circle(-radius * 0.3, -radius * 0.3, radius * 0.4, 0xffffff, 0.5);
              puyo.add(highlight1);

              const highlight2 = this.add.circle(radius * 0.2, -radius * 0.35, radius * 0.2, 0xffffff, 0.3);
              puyo.add(highlight2);

              const outline = this.add.circle(0, 0, radius);
              outline.setStrokeStyle(2, 0xffffff, 0.8);
              outline.setFillStyle(0, 0);
              puyo.add(outline);

              puyo.setData('color', color);
              puyo.setAlpha(isGhost ? 0.3 : customAlpha);
              puyo.setSize(CELL_SIZE, CELL_SIZE);

              if (!isGhost && customAlpha === 1) {
                  puyo.setScale(0);
                  puyo.setAngle(-180);
                  this.tweens.add({
                      targets: puyo,
                      scale: 1,
                      angle: 0,
                      duration: 300,
                      ease: 'Elastic.easeOut'
                  });

                  this.tweens.add({
                      targets: puyo,
                      scaleX: { from: 1, to: 1.08 },
                      scaleY: { from: 1, to: 0.92 },
                      duration: 800,
                      yoyo: true,
                      repeat: -1,
                      ease: 'Sine.easeInOut'
                  });
              }

              return puyo;
          }

          createPuyoPair() {
              const color1 = Phaser.Utils.Array.GetRandom(COLORS);
              const color2 = Phaser.Utils.Array.GetRandom(COLORS);
              return {
                  main: { color: color1, sprite: null },
                  sub: { color: color2, sprite: null },
                  col: Math.floor(COLS / 2),
                  row: 0,
                  rotation: 0
              };
          }

          spawnNewPair() {
              if (this.gameOver) return;

              this.currentPair = this.nextPair;
              this.nextPair = this.createPuyoPair();

              const startX = this.fieldOffsetX + this.currentPair.col * CELL_SIZE + CELL_SIZE / 2;
              const startY = this.currentPair.row * CELL_SIZE + CELL_SIZE / 2;

              this.currentPair.main.sprite = this.createPuyo(startX, startY, this.currentPair.main.color);
              this.currentPair.sub.sprite = this.createPuyo(startX, startY - CELL_SIZE, this.currentPair.sub.color);

              this.currentPair.ghostMain = null;
              this.currentPair.ghostSub = null;

              this.time.delayedCall(100, () => {
                  if (this.currentPair) {
                      this.updateGhostPieces();
                  }
              });

              this.updateNextDisplay();

              // „Éú„Éº„ÉÄ„Éº„É©„Ç§„É≥„ÉÅ„Çß„ÉÉ„ÇØÔºàdefeatTimer„ÅØcheckBorderLine„ÅßÁÆ°ÁêÜÔºâ
              this.checkBorderLine();
          }

          updateGhostPieces() {
              if (this.currentPair && this.currentPair.ghostMain) {
                  this.currentPair.ghostMain.destroy();
                  this.currentPair.ghostMain = null;
              }
              if (this.currentPair && this.currentPair.ghostSub) {
                  this.currentPair.ghostSub.destroy();
                  this.currentPair.ghostSub = null;
              }

              if (!this.currentPair || this.isMoving) return;

              let dropRow = this.currentPair.row;
              while (true) {
                  const testRow = dropRow + 1;
                  const positions = this.getPairPositions(this.currentPair.col, testRow, this.currentPair.rotation);
                  if (!this.isValidPosition(positions)) break;
                  dropRow = testRow;
              }

              if (dropRow === this.currentPair.row) return;

              const ghostPositions = this.getPairPositions(this.currentPair.col, dropRow, this.currentPair.rotation);

              const ghostMainX = this.fieldOffsetX + ghostPositions.main.col * CELL_SIZE + CELL_SIZE / 2;
              const ghostMainY = ghostPositions.main.row * CELL_SIZE + CELL_SIZE / 2;
              const ghostSubX = this.fieldOffsetX + ghostPositions.sub.col * CELL_SIZE + CELL_SIZE / 2;
              const ghostSubY = ghostPositions.sub.row * CELL_SIZE + CELL_SIZE / 2;

              this.currentPair.ghostMain = this.add.circle(
                  ghostMainX, ghostMainY, CELL_SIZE * 0.25,
                  COLOR_VALUES[this.currentPair.main.color], 0.4
              );
              this.currentPair.ghostMain.setDepth(50);
              this.currentPair.ghostMain.setStrokeStyle(1.5, 0x666666, 0.4);

              this.currentPair.ghostSub = this.add.circle(
                  ghostSubX, ghostSubY, CELL_SIZE * 0.25,
                  COLOR_VALUES[this.currentPair.sub.color], 0.4
              );
              this.currentPair.ghostSub.setDepth(50);
              this.currentPair.ghostSub.setStrokeStyle(1.5, 0x666666, 0.4);
          }

          updateNextDisplay() {
              this.nextContainer.removeAll(true);
              const next1 = this.createPuyo(0, 0, this.nextPair.main.color);
              const next2 = this.createPuyo(0, -CELL_SIZE, this.nextPair.sub.color);
              next1.setScale(0.6);
              next2.setScale(0.6);
              this.nextContainer.add([next1, next2]);
          }

          update(time) {
              if (this.gameOver || !this.currentPair || this.isMoving || !this.gameStarted) return;

              if (this.cursors.left.isDown && time > this.lastMoveTime + 150) {
                  this.movePair(-1);
                  this.lastMoveTime = time;
              } else if (this.cursors.right.isDown && time > this.lastMoveTime + 150) {
                  this.movePair(1);
                  this.lastMoveTime = time;
              }

              if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && time > this.lastRotateTime + 200) {
                  this.rotatePair();
                  this.lastRotateTime = time;
              }

              if (Phaser.Input.Keyboard.JustDown(this.cursors.down)) {
                  this.hardDrop();
              }

              // ÊïóÂåó„Çø„Ç§„Éû„ÉºÊõ¥Êñ∞
              if (this.defeatTimer) {
                  const remaining = Math.ceil(this.defeatTimer.getRemaining() / 1000);
                  this.defeatCountdownText.setText(remaining.toString());
                  this.defeatCountdownText.setPosition(
                      this.fieldOffsetX + COLS * CELL_SIZE / 2,
                      ROWS * CELL_SIZE / 2
                  );
                  this.defeatCountdownText.setVisible(true);
              } else {
                  this.defeatCountdownText.setVisible(false);
              }
          }

          movePair(dir) {
              const newCol = this.currentPair.col + dir;
              const positions = this.getPairPositions(newCol, this.currentPair.row, this.currentPair.rotation);

              if (this.isValidPosition(positions)) {
                  this.currentPair.col = newCol;
                  this.updatePairPosition();
                  this.updateGhostPieces();
                  this.resetLockDelay();
                  this.sendPieceUpdate();
              }
          }

          rotatePair() {
              const newRotation = (this.currentPair.rotation + 1) % 4;
              const positions = this.getPairPositions(this.currentPair.col, this.currentPair.row, newRotation);

              if (this.isValidPosition(positions)) {
                  this.currentPair.rotation = newRotation;
                  this.updatePairPosition();
                  this.updateGhostPieces();
                  this.resetLockDelay();
                  this.sendPieceUpdate();
              
                  this.tweens.add({
                      targets: this.currentPair.main.sprite,
                      angle: '+=360',
                      duration: 200,
                      ease: 'Back.easeOut'
                  });

                  this.tweens.add({
                      targets: this.currentPair.sub.sprite,
                      angle: '+=360',
                      duration: 200,
                      ease: 'Back.easeOut'
                  });
              }
          }

          resetLockDelay() {
              if (this.lockDelayTimer) {
                  this.lockDelayTimer.remove();
                  this.lockDelayTimer = null;
              }
              this.isOnGround = false;
          }

          hardDrop() {
              if (!this.currentPair || this.isMoving) return;

              let dropRow = this.currentPair.row;
              while (true) {
                  const testRow = dropRow + 1;
                  const positions = this.getPairPositions(this.currentPair.col, testRow, this.currentPair.rotation);
                  if (!this.isValidPosition(positions)) break;
                  dropRow = testRow;
              }

              const distance = dropRow - this.currentPair.row;
              if (distance > 0) {
                  this.currentPair.row = dropRow;

                  const positions = this.getPairPositions(
                      this.currentPair.col,
                      dropRow,
                      this.currentPair.rotation
                  );

                  this.tweens.add({
                      targets: this.currentPair.main.sprite,
                      x: this.fieldOffsetX + positions.main.col * CELL_SIZE + CELL_SIZE / 2,
                      y: positions.main.row * CELL_SIZE + CELL_SIZE / 2,
                      duration: 100,
                      ease: 'Power2'
                  });

                  this.tweens.add({
                      targets: this.currentPair.sub.sprite,
                      x: this.fieldOffsetX + positions.sub.col * CELL_SIZE + CELL_SIZE / 2,
                      y: positions.sub.row * CELL_SIZE + CELL_SIZE / 2,
                      duration: 100,
                      ease: 'Power2',
                      onComplete: () => {
                          this.lockPair();
                      }
                  });
              }

              // „Éï„Ç£„Éº„É´„ÉâÂÖ®‰Ωì„Çí„Éê„Ç¶„É≥„Éâ„Åï„Åõ„Çã„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
              const fieldElements = this.children.list.filter(child => 
                  child.getData('myField') || child.getData('myFieldBorder')
              );
              
               // Ëá™ÂàÜ„ÅÆ„Å∑„Çà„ÇÇÂê´„ÇÅ„Çã
               const myPuyos = [];
               for(let r=0; r<ROWS; r++){
                   for(let c=0; c<COLS; c++){
                       if(this.grid[r][c]) myPuyos.push(this.grid[r][c]);
                   }
               }
               
               this.tweens.add({
                   targets: [...fieldElements, ...myPuyos],
                   y: '+=10',
                   duration: 50,
                   yoyo: true,
                   ease: 'Sine.easeInOut'
               });
          }

          getPairPositions(col, row, rotation) {
              const main = { col: col, row: row };
              let sub;

              switch(rotation) {
                  case 0: sub = { col: col, row: row - 1 }; break;
                  case 1: sub = { col: col + 1, row: row }; break;
                  case 2: sub = { col: col, row: row + 1 }; break;
                  case 3: sub = { col: col - 1, row: row }; break;
              }

              return { main, sub };
          }

          isValidPosition(positions) {
              for (let pos of [positions.main, positions.sub]) {
                  if (pos.col < 0 || pos.col >= COLS || pos.row >= ROWS) return false;
                  if (pos.row >= 0 && this.grid[pos.row][pos.col] !== null) return false;
              }
              return true;
          }

          updatePairPosition() {
              const positions = this.getPairPositions(
                  this.currentPair.col,
                  this.currentPair.row,
                  this.currentPair.rotation
              );

              this.tweens.add({
                  targets: this.currentPair.main.sprite,
                  x: this.fieldOffsetX + positions.main.col * CELL_SIZE + CELL_SIZE / 2,
                  y: positions.main.row * CELL_SIZE + CELL_SIZE / 2,
                  duration: 100
              });

              this.tweens.add({
                  targets: this.currentPair.sub.sprite,
                  x: this.fieldOffsetX + positions.sub.col * CELL_SIZE + CELL_SIZE / 2,
                  y: positions.sub.row * CELL_SIZE + CELL_SIZE / 2,
                  duration: 100
              });
          }

          autoDrop() {
              if (!this.gameOver && this.currentPair && !this.isMoving && this.gameStarted) {
                  this.dropPair();
              }
          }

          dropPair() {
              const newRow = this.currentPair.row + 1;
              const positions = this.getPairPositions(this.currentPair.col, newRow, this.currentPair.rotation);

              if (this.isValidPosition(positions)) {
                  this.currentPair.row = newRow;
                  this.updatePairPosition();
                  this.updateGhostPieces();
                  this.resetLockDelay();
                  this.sendPieceUpdate();
              } else {
                  if (!this.isOnGround) {
                      this.isOnGround = true;
                      this.lockDelayTimer = this.time.delayedCall(500, () => {
                          this.lockPair();
                      });
                  }
              }
          }

          async lockPair() {
              this.isMoving = true;

              if (this.lockDelayTimer) {
                  this.lockDelayTimer.remove();
                  this.lockDelayTimer = null;
              }
              this.isOnGround = false;

              if (this.currentPair.ghostMain) {
                  this.currentPair.ghostMain.destroy();
                  this.currentPair.ghostMain = null;
              }
              if (this.currentPair.ghostSub) {
                  this.currentPair.ghostSub.destroy();
                  this.currentPair.ghostSub = null;
              }

              const positions = this.getPairPositions(
                  this.currentPair.col,
                  this.currentPair.row,
                  this.currentPair.rotation
              );

              if (positions.main.row >= 0) {
                  this.grid[positions.main.row][positions.main.col] = this.currentPair.main.sprite;
              } else {
                  this.currentPair.main.sprite.destroy();
              }

              if (positions.sub.row >= 0) {
                  this.grid[positions.sub.row][positions.sub.col] = this.currentPair.sub.sprite;
              } else {
                  this.currentPair.sub.sprite.destroy();
              }

              this.currentPair = null;

              this.chainCount = 0;
              await this.checkAndClearMatches();
              await this.applyGravity();

              // „Åä„Åò„ÇÉ„Åæ„Å∑„Çà„ÅÆÂá¶ÁêÜ
              if (this.pendingGarbage.length > 0) {
                  this.time.delayedCall(200, () => {
                      this.dropGarbagePuyos();
                  });
              }

              this.sendFieldUpdate();

              this.isMoving = false;
              this.spawnNewPair();
          }

          async checkAndClearMatches() {
              let hasMatches = true;
              let loopCount = 0;
              const MAX_LOOPS = 20;

              while (hasMatches && loopCount < MAX_LOOPS) {
                  loopCount++;
                  const matched = this.findMatches();

                  if (matched.length === 0) {
                      hasMatches = false;
                      this.chainText.setText('');
                  } else {
                      this.chainCount++;
                      if (this.chainCount > 1) {
                          this.chainText.setText(`${this.chainCount} ÈÄ£ÈéñÔºÅ`);
                          this.tweens.add({
                              targets: this.chainText,
                              scale: 1.5,
                              yoyo: true,
                              duration: 200
                          });
                      }

                      const positions = matched.map(m => ({
                          x: this.fieldOffsetX + m.col * CELL_SIZE + CELL_SIZE / 2,
                          y: m.row * CELL_SIZE + CELL_SIZE / 2
                      }));

                      await this.clearPuyos(matched);

                      this.score += matched.length * 10 * this.chainCount;
                      this.scoreText.setText(`„Çπ„Ç≥„Ç¢: ${this.score}`);

                      this.scoreText.setText(`„Çπ„Ç≥„Ç¢: ${this.score}`);

                      const garbageAmount = Math.floor((matched.length / 2) * this.garbageRate);
                      if (garbageAmount > 0) {
                          this.sendGarbage(garbageAmount, positions);
                      }

                      await this.applyGravity();
                      await this.delay(50);
                  }
              }
          }

          findMatches() {
              const visited = Array(ROWS).fill().map(() => Array(COLS).fill(false));
              const allMatches = [];

              for (let row = 0; row < ROWS; row++) {
                  for (let col = 0; col < COLS; col++) {
                      if (this.grid[row][col] && this.grid[row][col].active && !visited[row][col]) {
                          const puyo = this.grid[row][col];
                          // „Åä„Åò„ÇÉ„Åæ„Å∑„ÇàÔºàgrayÔºâ„ÅØËá™ÂàÜ„Åã„Çâ„ÅØÊ∂à„Åà„Å™„ÅÑ
                          if (puyo.getData('color') === 'gray') continue;

                          const group = this.floodFill(row, col, visited);
                          if (group.length >= 4) {
                              allMatches.push(...group);
                              
                              // Èö£Êé•„Åô„Çã„Åä„Åò„ÇÉ„Åæ„Å∑„Çà„ÇíÂ∑ª„ÅçËæº„ÅøÊ∂àÂéª
                              group.forEach(p => {
                                  const neighbors = [
                                      {r: p.row-1, c: p.col}, {r: p.row+1, c: p.col},
                                      {r: p.row, c: p.col-1}, {r: p.row, c: p.col+1}
                                  ];
                                  neighbors.forEach(n => {
                                      if (n.r >= 0 && n.r < ROWS && n.c >= 0 && n.c < COLS) {
                                          const neighborPuyo = this.grid[n.r][n.c];
                                          if (neighborPuyo && neighborPuyo.active && neighborPuyo.getData('color') === 'gray') {
                                              // „Åæ„Å†ËøΩÂä†„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøËøΩÂä†
                                              const alreadyAdded = allMatches.some(m => m.row === n.r && m.col === n.c);
                                              if (!alreadyAdded) {
                                                  allMatches.push({ row: n.r, col: n.c, isGarbage: true });
                                              }
                                          }
                                      }
                                  });
                              });
                          }
                      }
                  }
              }

              return allMatches;
          }

          floodFill(startRow, startCol, visited) {
              const startPuyo = this.grid[startRow][startCol];
              if (!startPuyo || !startPuyo.active) return [];

              const color = startPuyo.getData('color');
              if (!color || color === 'gray') return [];

              const group = [];
              const stack = [[startRow, startCol]];

              while (stack.length > 0) {
                  const [row, col] = stack.pop();

                  if (row < 0 || row >= ROWS || col < 0 || col >= COLS) continue;
                  if (visited[row][col]) continue;

                  const puyo = this.grid[row][col];
                  if (!puyo || !puyo.active || puyo.getData('color') !== color) continue;

                  visited[row][col] = true;
                  group.push({ row, col });

                  stack.push([row - 1, col], [row + 1, col], [row, col - 1], [row, col + 1]);
              }

              return group;
          }

          async clearPuyos(matches) {
              return new Promise(resolve => {
                  const uniqueMatches = [];
                  const seen = new Set();

                  for (const m of matches) {
                      const key = `${m.row},${m.col}`;
                      if (!seen.has(key)) {
                          seen.add(key);
                          uniqueMatches.push(m);
                      }
                  }

                  const sprites = [];

                  for (const m of uniqueMatches) {
                      if (this.grid[m.row] && this.grid[m.row][m.col]) {
                          const sprite = this.grid[m.row][m.col];
                          if (sprite && sprite.active && sprite.scene) {
                              sprites.push(sprite);
                          }
                      }
                  }

                  if (sprites.length === 0) {
                      resolve();
                      return;
                  }

                  for (const m of uniqueMatches) {
                      if (this.grid[m.row] && this.grid[m.row][m.col]) {
                          this.grid[m.row][m.col] = null;
                      }
                  }

                  if (this.chainCount > 1) {
                      try {
                          this.cameras.main.shake(100, 0.002 * this.chainCount);
                      } catch (e) {}
                  }

                  sprites.forEach((sprite, index) => {
                      if (!sprite || !sprite.active || !sprite.scene) return;

                      const color = sprite.getData('color');
                      const x = sprite.x;
                      const y = sprite.y;

                      for (let i = 0; i < 8; i++) {
                          const angle = (i / 8) * Math.PI * 2;
                          const distance = 40 + Math.random() * 20;

                          try {
                              const particle = this.add.circle(x, y, 6, COLOR_VALUES[color]);
                              this.tweens.add({
                                  targets: particle,
                                  x: x + Math.cos(angle) * distance,
                                  y: y + Math.sin(angle) * distance,
                                  alpha: 0,
                                  scale: 0.2,
                                  duration: 500 + Math.random() * 200,
                                  ease: 'Power2',
                                  onComplete: () => {
                                      try {
                                          if (particle && particle.scene) particle.destroy();
                                      } catch (e) {}
                                  }
                              });
                          } catch (e) {}
                      }

                      try {
                          const ring = this.add.circle(x, y, 10, 0xffffff, 0.8);
                          this.tweens.add({
                              targets: ring,
                              radius: 40,
                              alpha: 0,
                              duration: 400,
                              onComplete: () => {
                                  try {
                                      if (ring && ring.scene) ring.destroy();
                                  } catch (e) {}
                              }
                          });
                      } catch (e) {}
                  });

                  try {
                      this.tweens.add({
                          targets: sprites,
                          scale: { from: 1, to: 0 },
                          alpha: { from: 1, to: 0 },
                          duration: 400,
                          ease: 'Back.easeIn',
                          onComplete: () => {
                              sprites.forEach(sprite => {
                                  try {
                                      if (sprite && sprite.scene) {
                                          this.tweens.killTweensOf(sprite);
                                          sprite.destroy();
                                      }
                                  } catch (e) {}
                              });
                              resolve();
                          }
                      });
                  } catch (e) {
                      sprites.forEach(sprite => {
                          try {
                              if (sprite && sprite.scene) {
                                  this.tweens.killTweensOf(sprite);
                                  sprite.destroy();
                              }
                          } catch (e) {}
                      });
                      resolve();
                  }
              });
          }

          async applyGravity() {
              let moved = true;

              while (moved) {
                  moved = false;
                  for (let row = ROWS - 2; row >= 0; row--) {
                      for (let col = 0; col < COLS; col++) {
                          if (this.grid[row][col] && !this.grid[row + 1][col]) {
                              this.grid[row + 1][col] = this.grid[row][col];
                              this.grid[row][col] = null;

                              this.tweens.add({
                                  targets: this.grid[row + 1][col],
                                  y: (row + 1) * CELL_SIZE + CELL_SIZE / 2,
                                  duration: 150,
                                  ease: 'Bounce.easeOut'
                              });

                              moved = true;
                          }
                      }
                  }
                  if (moved) await this.delay(150);
              }
          }

          delay(ms) {
              return new Promise(resolve => this.time.delayedCall(ms, resolve));
          }

          sendFieldUpdate() {
              if (ws && ws.readyState === WebSocket.OPEN) {
                  const gridData = [];
                  for (let row = 0; row < ROWS; row++) {
                      gridData[row] = [];
                      for (let col = 0; col < COLS; col++) {
                          if (this.grid[row][col] && this.grid[row][col].active) {
                              gridData[row][col] = this.grid[row][col].getData('color');
                          } else {
                              gridData[row][col] = null;
                          }
                      }
                  }

                  ws.send(JSON.stringify({
                      type: 'game_update',
                      gameState: gridData
                  }));
              }
          }

          sendGarbage(amount, sourcePositions) {
              if (ws && ws.readyState === WebSocket.OPEN) {
                  const colors = [];
                  for (let i = 0; i < amount; i++) {
                      // ÈÄÅ„Çã„ÅÆ„ÅØÂÖ®„Å¶„Åä„Åò„ÇÉ„Åæ„Å∑„Çà(gray)
                      colors.push('gray');
                  }

                  ws.send(JSON.stringify({
                      type: 'send_garbage',
                      amount: amount,
                      colors: colors,
                      positions: sourcePositions
                  }));
              }
          }

          receiveGarbage(fromPlayerId, amount, colors, sourcePositions) {
              // ÊîªÊíÉÂÖÉ„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÇíÂèñÂæó
              const sourceField = this.opponentFields.get(fromPlayerId);
              if (!sourceField) return;

              // „Åä„Åò„ÇÉ„Åæ„Å∑„Çà„Çí„Ç≠„É•„Éº„Å´ËøΩÂä†
              for (let i = 0; i < amount; i++) {
                  this.pendingGarbage.push(colors[i]);
              }

              // ÊîªÊíÉÂÖÉ„Åã„ÇâËá™ÂàÜ„ÅÆ„Éï„Ç£„Éº„É´„Éâ„Å∏È£õ„Çì„Åß„Åè„Çã„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
              sourcePositions.slice(0, amount).forEach((pos, i) => {
                  // Áõ∏Êâã„Éï„Ç£„Éº„É´„Éâ„ÅÆ„Çπ„Ç±„Éº„É´Ë™øÊï¥„Åï„Çå„Åü‰ΩçÁΩÆ„Åã„ÇâÈ£õ„Å∞„Åô
                  const sourceX = sourceField.x + sourceField.width / 2;
                  const sourceY = sourceField.y + sourceField.height / 2;

                  if (this.is1v1Mode) {
                       // 1v1„ÅÆÂ†¥Âêà„ÄÅsourceField.x„ÅØÂ∑¶‰∏ä„ÄÅsourceField.width„ÅØÈÄöÂ∏∏„Çµ„Ç§„Ç∫
                       // „Å™„ÅÆ„Åß‰∏äË®òË®àÁÆó„ÅßOK? createOpponentFields„ÅÆÂÆüË£Ö„Åß„ÅØ
                       // centerX = opponentX + COLS * CELL_SIZE / 2 „Å™„ÅÆ„Åß
                       // 0.5ÂÄç„Çπ„Ç±„Éº„É´„ÅÆÂ†¥Âêà„Å®1.0ÂÄç„Çπ„Ç±„Éº„É´„ÅÆÂ†¥Âêà„Åß‰∏≠ÂøÉ‰ΩçÁΩÆ„ÅÆË®àÁÆó„ÅåÂêà„ÅÜ„ÅãÁ¢∫Ë™ç
                       // createOpponentFields„ÅÆ1v1: x = opponentX (Â∑¶Á´Ø)
                       // createOpponentFields„ÅÆÈÄöÂ∏∏: x = Â∑¶Á´Ø
                  }

                  const particle = this.add.circle(sourceX, sourceY, CELL_SIZE * 0.25, 0x888888, 0.9);
                  particle.setDepth(200);

                  // Ëá™ÂàÜ„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÅÆ‰∏äÈÉ®„Å∏
                  const targetX = this.fieldOffsetX + COLS * CELL_SIZE / 2;
                  const targetY = -50;

                  this.tweens.add({
                      targets: particle,
                      x: targetX,
                      y: targetY,
                      scale: 0.8,
                      alpha: 0.6,
                      duration: 600,
                      delay: i * 50,
                      ease: 'Power2',
                      onComplete: () => {
                          particle.destroy();
                      }
                  });
              });
          }

          async dropGarbagePuyos() {
              if (this.pendingGarbage.length === 0) return;

              const garbageToDrop = [...this.pendingGarbage];
              this.pendingGarbage = [];

              for (const color of garbageToDrop) {
                  const col = Phaser.Math.Between(0, COLS - 1);
                  const startY = -CELL_SIZE;
                  const x = this.fieldOffsetX + col * CELL_SIZE + CELL_SIZE / 2;

                  let targetRow = 0;
                  for (let row = ROWS - 1; row >= 0; row--) {
                      if (!this.grid[row][col]) {
                          targetRow = row;
                          break;
                      }
                  }

                  const puyo = this.createPuyo(x, startY, color);
                  this.grid[targetRow][col] = puyo;

                  this.tweens.add({
                      targets: puyo,
                      y: targetRow * CELL_SIZE + CELL_SIZE / 2,
                      duration: 300 + targetRow * 30,
                      ease: 'Bounce.easeOut'
                  });

                  await this.delay(150);
              }

              await this.delay(300);
              await this.applyGravity();
              this.checkBorderLine();
          }

          checkBorderLine() {
              let isDanger = false;
              // BORDER_LINE„ÇíË∂Ö„Åà„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ (index < BORDER_LINE)
              // BORDER_LINE (index 4) „Å´„Å∑„Çà„Åå„ÅÇ„Çã„ÅÆ„ÅØ„Çª„Éº„Éï
              // grid[3]‰ª•‰∏ã„Å´„Å∑„Çà„Åå„ÅÇ„Çã„Å®„Ç¢„Ç¶„Éà
              for (let col = 0; col < COLS; col++) {
                   if (this.grid[BORDER_LINE - 1][col] !== null) {
                       isDanger = true;
                       break;
                   }
              }

              if (isDanger) {
                  if (!this.defeatTimer && !this.gameOver) {
                      // Ë®≠ÂÆö„Åï„Çå„ÅüÊôÇÈñìÔºà„Éá„Éï„Ç©„É´„Éà10ÁßíÔºâ
                      const defeatTime = (this.gameSettings && this.gameSettings.defeatTime) ? this.gameSettings.defeatTime : 10;
                      
                      // „Çø„Ç§„Éû„ÉºÈñãÂßã
                      this.defeatTimer = this.time.delayedCall(defeatTime * 1000, () => {
                          this.endGame();
                      });
                      // „Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥Ë°®Á§∫„ÅØupdate„ÅßÂà∂Âæ°
                      this.defeatCountdownText.setVisible(true);
                      
                      // Êû†„ÇíËµ§„Åè„Åô„Çã
                      if (this.myFieldBorder) {
                          this.myFieldBorder.setStrokeStyle(4, 0xff0000);
                      }
                  }
              } else {
                  // Ëß£Èô§
                  if (this.defeatTimer) {
                      this.defeatTimer.remove();
                      this.defeatTimer = null;
                      this.defeatCountdownText.setVisible(false);
                      
                      // Êû†„ÇíÂÖÉ„Å´Êàª„Åô
                      if (this.myFieldBorder) {
                          this.myFieldBorder.setStrokeStyle(4, 0x2c3e50);
                      }
                  }
              }
          }

          handlePlayerDefeated(playerId) {
              // ÊïóÂåó„Åó„Åü„Éó„É¨„Ç§„É§„Éº„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÇíÂ¥©Â£ä„Åï„Åõ„Çã
              const field = this.opponentFields.get(playerId);
              if (!field) return;

              this.collapseField(field);

              // ÁîüÂ≠ò„Éó„É¨„Ç§„É§„Éº„É™„Çπ„Éà„Åã„ÇâÂâäÈô§
              this.alivePlayers = this.alivePlayers.filter(id => id !== playerId);

              // 1v1„Å´„Å™„Å£„Åü„ÅãÁ¢∫Ë™ç
              if (this.alivePlayers.length === 2) {
                  this.switchTo1v1();
              }
          }

          collapseField(field) {
              // Êû†„ÅÆÂ¥©Â£ä„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
              if (field.border) {
                  this.tweens.add({
                      targets: field.border,
                      angle: Phaser.Math.Between(-10, 10),
                      scaleX: 0.9,
                      scaleY: 1.1,
                      alpha: 0,
                      duration: 800,
                      ease: 'Power2',
                      onComplete: () => {
                          if (field.border) field.border.destroy();
                      }
                  });
              }
              
              // ÁîªÈù¢ÊåØÂãï (Â∞è)
              this.cameras.main.shake(300, 0.01);

              // ËÉåÊôØ„ÅÆÂ¥©Â£ä
              if (field.bg) {
                  this.tweens.add({
                      targets: field.bg,
                      alpha: 0,
                      scaleY: 0,
                      duration: 800,
                      ease: 'Power2',
                      onComplete: () => {
                          if (field.bg) field.bg.destroy();
                      }
                  });
              }

              // „Å∑„Çà„Çí„Éê„É©„Éê„É©„Å´Â¥©„Åô (ÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„ÉàËøΩÂä†)
              for (let row = 0; row < ROWS; row++) {
                  for (let col = 0; col < COLS; col++) {
                      if (field.grid[row][col]) {
                          const puyo = field.grid[row][col];
                          const angle = Phaser.Math.Between(0, 360);
                          const distance = Phaser.Math.Between(50, 150);
                          
                          // ÁàÜÁô∫„Éë„Éº„ÉÜ„Ç£„ÇØ„É´
                          for (let i = 0; i < 3; i++) {
                              const pData = puyo.getData('color') || 'gray';
                              const pColor = COLOR_VALUES[pData];
                              const p = this.add.circle(puyo.x, puyo.y, 4, pColor, 1);
                              const pAngle = Phaser.Math.Between(0, 360);
                              const pDist = Phaser.Math.Between(50, 200);
                              
                              this.tweens.add({
                                  targets: p,
                                  x: puyo.x + Math.cos(pAngle) * pDist,
                                  y: puyo.y + Math.sin(pAngle) * pDist,
                                  alpha: 0,
                                  duration: 600,
                                  ease: 'Power2',
                                  onComplete: () => p.destroy()
                              });
                          }

                          this.tweens.add({
                              targets: puyo,
                              x: puyo.x + Math.cos(angle) * distance,
                              y: puyo.y + Math.sin(angle) * distance,
                              angle: Phaser.Math.Between(-360, 360),
                              alpha: 0,
                              scale: 0,
                              duration: 800 + Math.random() * 400,
                              delay: (row + col) * 20,
                              ease: 'Power2',
                              onComplete: () => {
                                  if (puyo && puyo.scene) puyo.destroy();
                              }
                          });
                      }
                  }
              }

              // „Éó„É¨„Ç§„É§„ÉºÂêç„ÇíËµ§„Åè„Éï„Çß„Éº„Éâ„Ç¢„Ç¶„Éà
              if (field.name) {
                  field.name.setColor('#ff0000');
                  this.tweens.add({
                      targets: field.name,
                      alpha: 0,
                      duration: 800,
                      onComplete: () => {
                          if (field.name) field.name.destroy();
                      }
                  });
              }
          }

          switchTo1v1() {
               if (this.is1v1Mode) return;
               this.is1v1Mode = true;
               console.log('Switching to 1v1 mode layout');
               
               // ÁèæÂú®„ÅÆ„Éï„Ç£„Éº„É´„Éâ‰ΩçÁΩÆÔºàËá™ÂàÜÔºâ
               const oldFieldX = this.fieldOffsetX;
               
               // Êñ∞„Åó„ÅÑ„Ç™„Éï„Çª„ÉÉ„ÉàË®àÁÆó
               const fieldWidth = COLS * CELL_SIZE;
               const totalWidth = fieldWidth * 2 + 100;
               const newFieldX = (1000 - totalWidth) / 2;
               const diffX = newFieldX - oldFieldX;
               
               this.fieldOffsetX = newFieldX;
               
               // ËÉåÊôØ„ÉªÊû†„ÅÆÂÜçÁîüÊàê„ÅÆ„Åü„ÇÅ„ÄÅÊó¢Â≠ò„ÅÆmyField„Çø„Ç∞‰ªò„Åç„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂâäÈô§
               // („Åü„Å†„Åó„Ç∞„É™„ÉÉ„ÉâÂÜÖ„ÅÆ„Å∑„Çà„ÅØÊÆã„Åô)
               const children = this.children.list.slice(); // „Ç≥„Éî„Éº„Çí‰ΩúÊàê
               children.forEach(child => {
                   if (child.getData('myField') || child.getData('myFieldBorder')) {
                       child.destroy();
                   }
               });
               
               // Êñ∞„Åó„ÅÑ‰ΩçÁΩÆ„ÅßËá™ÂàÜ„Éï„Ç£„Éº„É´„ÉâÊû†ÁîüÊàê
               this.createField(newFieldX, 'YOU');
               this.scoreText.setPosition(newFieldX, ROWS * CELL_SIZE + 20);
               this.chainText.setPosition(newFieldX + COLS * CELL_SIZE / 2, ROWS * CELL_SIZE / 2);
               this.nextContainer.setPosition(newFieldX + 30, 50);
               if (this.defeatCountdownText) {
                    this.defeatCountdownText.setPosition(
                        newFieldX + COLS * CELL_SIZE / 2,
                        ROWS * CELL_SIZE / 2
                    );
               }

               // Ëá™ÂàÜ„ÅÆ„Å∑„Çà„Çπ„Éó„É©„Ç§„Éà„ÇíÁßªÂãï
               for (let row = 0; row < ROWS; row++) {
                   for (let col = 0; col < COLS; col++) {
                       if (this.grid[row][col]) {
                           this.grid[row][col].x += diffX;
                       }
                   }
               }
               // Êìç‰Ωú‰∏≠„ÅÆ„Éö„Ç¢„ÇÇÁßªÂãï
               if (this.currentPair) {
                   if (this.currentPair.main.sprite) this.currentPair.main.sprite.x += diffX;
                   if (this.currentPair.sub.sprite) this.currentPair.sub.sprite.x += diffX;
                   this.updateGhostPieces(); // „Ç¥„Éº„Çπ„ÉàÂÜçÊèèÁîª
               }
               
               // Áõ∏Êâã„Éï„Ç£„Éº„É´„Éâ„ÅÆÊõ¥Êñ∞ (ÊÆã„Çä1‰∫∫„ÅÆ„ÅØ„Åö)
               // Êó¢Â≠ò„ÅÆÁõ∏Êâã„Éï„Ç£„Éº„É´„ÉâÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Å¶ÂâäÈô§
               this.opponentFields.forEach((field, pid) => {
                   if (field.bg) field.bg.destroy();
                   if (field.border) field.border.destroy();
                   if (field.name) field.name.destroy();
                   // „Ç∞„É™„ÉÉ„Éâ„ÅÆ„Å∑„Çà„ÇÇ‰∏ÄÊó¶ÂâäÈô§ÔºàÊ¨°„ÅÆÊõ¥Êñ∞„ÅßÂÜçÊèèÁîª„Åï„Çå„Çã„Åå„ÄÅ‰ΩçÁΩÆ„Åå„Åö„Çå„Çã„ÅÆ„ÅßÊ∂à„Åó„Å¶„Åä„ÅèÔºâ
                   for(let r=0; r<ROWS; r++){
                       for(let c=0; c<COLS; c++){
                           if(field.grid[r][c]) field.grid[r][c].destroy();
                       }
                   }
                   if (field.pieceContainer) field.pieceContainer.destroy();
               });
               this.opponentFields.clear();
               
               // ÊÆã„Å£„Å¶„ÅÑ„Çã„Éó„É¨„Ç§„É§„Éº„Å´ÂØæ„Åó„Å¶createOpponentFields„ÇíÂëº„Å∂
               // alivePlayers„ÅØÊó¢„Å´Êõ¥Êñ∞„Åï„Çå„Å¶„ÅÑ„Çã„ÅØ„Åö
               const opponents = this.players.filter(p => this.alivePlayers.includes(p.id) && p.id !== myPlayerId);
               this.createOpponentFields(opponents); // „Åì„Çå„Åß1v1ÈÖçÁΩÆ„Å´„Å™„Çã„ÅØ„Åö
          }

          sendPieceUpdate() {
              if (ws && ws.readyState === WebSocket.OPEN && this.currentPair) {
                  ws.send(JSON.stringify({
                      type: 'piece_update',
                      data: {
                          col: this.currentPair.col,
                          row: this.currentPair.row,
                          rotation: this.currentPair.rotation,
                          colors: {
                              main: this.currentPair.main.color,
                              sub: this.currentPair.sub.color
                          }
                      }
                  }));
              }
          }

          updateOpponentPiece(playerId, data) {
              // 1v1„É¢„Éº„Éâ‰ª•Â§ñ„Åß„ÅØË°®Á§∫„Åó„Å™„ÅÑ („É™„ÇØ„Ç®„Çπ„ÉàÂØæÂøú)
              if (!this.is1v1Mode) return;
              
              const field = this.opponentFields.get(playerId);
              if (!field) return;
              
              // ÂâçÂõû„ÅÆ„Éî„Éº„ÇπË°®Á§∫„ÇíÂâäÈô§
              if (!field.pieceContainer) {
                  field.pieceContainer = this.add.container(0, 0);
              }
              field.pieceContainer.removeAll(true);
              
              // Áõ∏Êâã„Éï„Ç£„Éº„É´„Éâ‰∏ä„ÅÆÂ∫ßÊ®ôË®àÁÆó
              // data: col, row (grid coord), rotation
              const positions = this.getPairPositions(data.col, data.row, data.rotation);
              
              // ÊèèÁîª (ÂçäÈÄèÊòé„ÅßË°®Á§∫)
              const drawPiece = (pos, color) => {
                  if (pos.row < 0) return; // ÁîªÈù¢Â§ñ
                  // 1v1„Å™„ÅÆ„Åßscale 1.0ÂâçÊèê
                  const x = field.x + pos.col * CELL_SIZE + CELL_SIZE/2;
                  const y = field.y + pos.row * CELL_SIZE + CELL_SIZE/2;
                  
                  const puyo = this.add.circle(x, y, CELL_SIZE * 0.38, COLOR_VALUES[color], 0.6);
                  puyo.setStrokeStyle(2, 0xffffff, 0.5);
                  field.pieceContainer.add(puyo);
              };
              
              drawPiece(positions.main, data.colors.main);
              drawPiece(positions.sub, data.colors.sub);
          }

          handleGameEnd(winnerId, isWinner) {
              this.gameOver = true;
              if (this.dropTimer) this.dropTimer.remove();
              if (this.defeatTimer) this.defeatTimer.remove();
              this.defeatCountdownText.setVisible(false);

              if (isWinner) {
                  this.showMessage('üèÜ ÂãùÂà©ÔºÅ üèÜ');
              } else {
                  // Ë≤†„Åë„ÅüÂ†¥Âêà„ÅØËá™ÂàÜ„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÇíÂ¥©Â£ä
                  this.collapseMyField();
                  this.showMessage('ÊïóÂåó...');
                  
                  // Ë¶≥Êà¶„É°„ÉÉ„Çª„Éº„Ç∏
                   this.waitingText = this.add.text(
                        this.cameras.main.centerX,
                        this.cameras.main.centerY + 100,
                        'Ë¶≥Êà¶‰∏≠...',
                        {
                            fontSize: '24px',
                            fontFamily: '"JetBrains Mono"',
                            fill: '#aaa',
                            fontStyle: 'bold'
                        }
                   ).setOrigin(0.5);
              }
              
              // Ë©¶ÂêàÁµÇ‰∫ÜÔºàÂãùËÄÖÊ±∫ÂÆöÔºâÂæå„ÅØÂÖ®Âì°„É≠„Éì„Éº„Å∏
              this.time.delayedCall(2000, () => {
                  this.resetGame();
                  returnToLobby();
              });
          }

          collapseMyField() {
              // Ëá™ÂàÜ„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÅÆÊû†„ÇíÂ¥©Â£ä
              if (this.myFieldBorder) {
                  this.tweens.add({
                      targets: this.myFieldBorder,
                      angle: Phaser.Math.Between(-15, 15),
                      scaleX: 0.8,
                      scaleY: 1.2,
                      alpha: 0,
                      duration: 1000,
                      ease: 'Power2'
                  });
              }
              
              // ÁîªÈù¢ÊåØÂãï
              this.cameras.main.shake(500, 0.02);

              // ËÉåÊôØ„Å®„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„ÇíÂ¥©Â£ä
              this.children.list.forEach(child => {
                  if (child.getData && child.getData('myField')) {
                      this.tweens.add({
                          targets: child,
                          alpha: 0,
                          scaleY: 0,
                          duration: 1000,
                          ease: 'Power2'
                      });
                  }
              });

              // „Å∑„Çà„Çí„Éê„É©„Éê„É©„Å´
              for (let row = 0; row < ROWS; row++) {
                  for (let col = 0; col < COLS; col++) {
                      if (this.grid[row][col]) {
                          const puyo = this.grid[row][col];
                          const angle = Phaser.Math.Between(0, 360);
                          const distance = Phaser.Math.Between(100, 250);

                          this.tweens.add({
                              targets: puyo,
                              x: puyo.x + Math.cos(angle) * distance,
                              y: puyo.y + Math.sin(angle) * distance,
                              angle: Phaser.Math.Between(-720, 720),
                              alpha: 0,
                              scale: 0,
                              duration: 1000 + Math.random() * 500,
                              delay: (row + col) * 30,
                              ease: 'Power3'
                          });
                      }
                  }
              }
          }

          showMessage(text) {
              const message = this.add.text(
                  this.cameras.main.centerX,
                  this.cameras.main.centerY,
                  text,
                  {
                      fontSize: '48px',
                      fontFamily: '"JetBrains Mono"',
                      fill: '#fff',
                      fontStyle: 'bold',
                      stroke: '#000',
                      strokeThickness: 6
                  }
              ).setOrigin(0.5).setDepth(1000);

              message.setAlpha(0);
              this.tweens.add({
                  targets: message,
                  alpha: 1,
                  scale: 1.3,
                  duration: 600,
                  ease: 'Elastic.easeOut'
              });
          }

          endGame() {
              this.gameOver = true;
              if (this.dropTimer) this.dropTimer.remove();
              if (this.defeatTimer) this.defeatTimer.remove();
              this.defeatCountdownText.setVisible(false);

              this.collapseMyField();

              if (ws && ws.readyState === WebSocket.OPEN) {
                  ws.send(JSON.stringify({
                      type: 'game_over'
                  }));
              }
          }

          resetGame() {
              this.gameStarted = false;
              this.score = 0;
              this.gameOver = false;
              this.isMoving = false;
              this.chainCount = 0;
              this.pendingGarbage = [];
              this.players = [];
              this.alivePlayers = [];

              this.children.removeAll(true);
              this.opponentFields.clear();

              for (let row = 0; row < ROWS; row++) {
                  this.grid[row] = [];
                  for (let col = 0; col < COLS; col++) {
                      this.grid[row][col] = null;
                  }
              }
          }
      }

      let game = null;

      function initGame() {
          if (game) return;

          const config = {
              type: Phaser.WEBGL,
              canvas: document.createElement('canvas'),
              width: 1000,
              height: 700,
              parent: 'game-container',
              backgroundColor: '#ffffff',
              scene: MultiplayerPuyoPuyo,
              render: {
                  antialias: true,
                  pixelArt: false,
                  roundPixels: false,
                  transparent: false,
                  clearBeforeRender: true,
                  preserveDrawingBuffer: false,
                  powerPreference: 'high-performance',
                  batchSize: 2048
              },
              scale: {
                  mode: Phaser.Scale.FIT,
                  autoCenter: Phaser.Scale.CENTER_BOTH,
                  width: 1000,
                  height: 700,
                  parent: 'game-container'
              },
              dom: {
                  createContainer: false
              },
              fps: {
                  target: 120,
                  forceSetTimeOut: false,
                  min: 30,
                  smoothStep: true
              }
          };

          game = new Phaser.Game(config);
      }

      window.addEventListener('load', () => {
          connectWebSocket();
          initGame();
      });
    </script>
  </body>
</html>
